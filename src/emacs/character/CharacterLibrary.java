package emacs.character;
import java.util.Collections;
import java.util.Iterator;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Runtime;
/**
 * Wrapper for library <b>character</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("character") 
@Runtime(CRuntime.class) 
public class CharacterLibrary {
	static {
		BridJ.register();
	}
	/**
	 * enum values<br>
	 * <i>native declaration : character.h:40</i>
	 */
	public enum unicode_category_t implements IntValuedEnum<unicode_category_t > {
		UNICODE_CATEGORY_UNKNOWN(0),
		UNICODE_CATEGORY_Lu(1),
		UNICODE_CATEGORY_Ll(2),
		UNICODE_CATEGORY_Lt(3),
		UNICODE_CATEGORY_Lm(4),
		UNICODE_CATEGORY_Lo(5),
		UNICODE_CATEGORY_Mn(6),
		UNICODE_CATEGORY_Mc(7),
		UNICODE_CATEGORY_Me(8),
		UNICODE_CATEGORY_Nd(9),
		UNICODE_CATEGORY_Nl(10),
		UNICODE_CATEGORY_No(11),
		UNICODE_CATEGORY_Pc(12),
		UNICODE_CATEGORY_Pd(13),
		UNICODE_CATEGORY_Ps(14),
		UNICODE_CATEGORY_Pe(15),
		UNICODE_CATEGORY_Pi(16),
		UNICODE_CATEGORY_Pf(17),
		UNICODE_CATEGORY_Po(18),
		UNICODE_CATEGORY_Sm(19),
		UNICODE_CATEGORY_Sc(20),
		UNICODE_CATEGORY_Sk(21),
		UNICODE_CATEGORY_So(22),
		UNICODE_CATEGORY_Zs(23),
		UNICODE_CATEGORY_Zl(24),
		UNICODE_CATEGORY_Zp(25),
		UNICODE_CATEGORY_Cc(26),
		UNICODE_CATEGORY_Cf(27),
		UNICODE_CATEGORY_Cs(28),
		UNICODE_CATEGORY_Co(29),
		UNICODE_CATEGORY_Cn(30);
		unicode_category_t(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<unicode_category_t > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<unicode_category_t > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// <i>native declaration : character.h</i>
	public static final int MAX_CHAR = (int)4194303;
	/// <i>native declaration : character.h</i>
	public static final int MIN_MULTIBYTE_LEADING_CODE = (int)192;
	/// <i>native declaration : character.h</i>
	public static final int MAX_UNICODE_CHAR = (int)1114111;
	/// <i>native declaration : character.h</i>
	public static final int MAX_4_BYTE_CHAR = (int)2097151;
	/// <i>native declaration : character.h</i>
	public static final int MAX_2_BYTE_CHAR = (int)2047;
	/// <i>native declaration : character.h</i>
	public static final int MAX_3_BYTE_CHAR = (int)65535;
	/// <i>native declaration : character.h</i>
	public static final int MAX_5_BYTE_CHAR = (int)4194175;
	/// <i>native declaration : character.h</i>
	public static final int MAX_MULTIBYTE_LEADING_CODE = (int)248;
	/// <i>native declaration : character.h</i>
	public static final int MAX_1_BYTE_CHAR = (int)127;
	/// <i>native declaration : character.h</i>
	public static final int MAX_MULTIBYTE_LENGTH = (int)5;
	/**
	 * Original signature : <code>int char_resolve_modifier_mask(int)</code><br>
	 * <i>native declaration : character.h:42</i>
	 */
	public static native int char_resolve_modifier_mask(int int1);
	/**
	 * Original signature : <code>int char_string(unsigned, unsigned char*)</code><br>
	 * <i>native declaration : character.h:44</i>
	 */
	public static native int char_string(int u1, Pointer<Byte > charPtr1);
	/**
	 * Original signature : <code>int string_char(const unsigned char*, const unsigned char**, int*)</code><br>
	 * <i>native declaration : character.h:46</i>
	 */
	public static native int string_char(Pointer<Byte > charPtr1, Pointer<Pointer<Byte > > charPtrPtr1, Pointer<Integer > intPtr1);
	/**
	 * Original signature : <code>int translate_char(int)</code><br>
	 * <i>native declaration : character.h:48</i>
	 */
	public static native int translate_char(int c);
	/**
	 * Original signature : <code>int char_printable_p(int)</code><br>
	 * <i>native declaration : character.h:50</i>
	 */
	public static native int char_printable_p(int c);
	/**
	 * Original signature : <code>void parse_str_as_multibyte(const unsigned char*, EMACS_INT*, EMACS_INT*)</code><br>
	 * <i>native declaration : character.h:52</i>
	 */
	public static native void parse_str_as_multibyte(Pointer<Byte > charPtr1, Pointer<CharacterLibrary.EMACS_INT > EMACS_INTPtr1, Pointer<CharacterLibrary.EMACS_INT > EMACS_INTPtr2);
	/**
	 * Original signature : <code>EMACS_INT count_size_as_multibyte(const unsigned char*, EMACS_INT)</code><br>
	 * <i>native declaration : character.h:54</i>
	 */
	public static native CharacterLibrary.EMACS_INT count_size_as_multibyte(Pointer<Byte > charPtr1, CharacterLibrary.EMACS_INT EMACS_INT1);
	/**
	 * Original signature : <code>EMACS_INT str_as_multibyte(unsigned char*, EMACS_INT, EMACS_INT, EMACS_INT*)</code><br>
	 * <i>native declaration : character.h:56</i>
	 */
	public static native CharacterLibrary.EMACS_INT str_as_multibyte(Pointer<Byte > charPtr1, CharacterLibrary.EMACS_INT EMACS_INT1, CharacterLibrary.EMACS_INT EMACS_INT2, Pointer<CharacterLibrary.EMACS_INT > EMACS_INTPtr1);
	/**
	 * Original signature : <code>EMACS_INT str_to_multibyte(unsigned char*, EMACS_INT, EMACS_INT)</code><br>
	 * <i>native declaration : character.h:58</i>
	 */
	public static native CharacterLibrary.EMACS_INT str_to_multibyte(Pointer<Byte > charPtr1, CharacterLibrary.EMACS_INT EMACS_INT1, CharacterLibrary.EMACS_INT EMACS_INT2);
	/**
	 * Original signature : <code>EMACS_INT str_as_unibyte(unsigned char*, EMACS_INT)</code><br>
	 * <i>native declaration : character.h:60</i>
	 */
	public static native CharacterLibrary.EMACS_INT str_as_unibyte(Pointer<Byte > charPtr1, CharacterLibrary.EMACS_INT EMACS_INT1);
	/**
	 * Original signature : <code>EMACS_INT str_to_unibyte(const unsigned char*, unsigned char*, EMACS_INT, int)</code><br>
	 * <i>native declaration : character.h:62</i>
	 */
	public static native CharacterLibrary.EMACS_INT str_to_unibyte(Pointer<Byte > charPtr1, Pointer<Byte > charPtr2, CharacterLibrary.EMACS_INT EMACS_INT1, int int1);
	/**
	 * Original signature : <code>EMACS_INT strwidth(const char*, EMACS_INT)</code><br>
	 * <i>native declaration : character.h:64</i>
	 */
	public static native CharacterLibrary.EMACS_INT strwidth(Pointer<Byte > charPtr1, CharacterLibrary.EMACS_INT EMACS_INT1);
	/**
	 * Original signature : <code>EMACS_INT c_string_width(const unsigned char*, EMACS_INT, int, EMACS_INT*, EMACS_INT*)</code><br>
	 * <i>native declaration : character.h:66</i>
	 */
	public static native CharacterLibrary.EMACS_INT c_string_width(Pointer<Byte > charPtr1, CharacterLibrary.EMACS_INT EMACS_INT1, int int1, Pointer<CharacterLibrary.EMACS_INT > EMACS_INTPtr1, Pointer<CharacterLibrary.EMACS_INT > EMACS_INTPtr2);
	/**
	 * Original signature : <code>EMACS_INT lisp_string_width(EMACS_INT, EMACS_INT*, EMACS_INT*)</code><br>
	 * <i>native declaration : character.h:68</i>
	 */
	public static native CharacterLibrary.EMACS_INT lisp_string_width(CharacterLibrary.EMACS_INT EMACS_INT1, Pointer<CharacterLibrary.EMACS_INT > EMACS_INTPtr1, Pointer<CharacterLibrary.EMACS_INT > EMACS_INTPtr2);
	/**
	 * Original signature : <code>Lisp_Object string_escape_byte8(Lisp_Object)</code><br>
	 * <i>native declaration : character.h:72</i>
	 */
	public static native CharacterLibrary.Lisp_Object string_escape_byte8(CharacterLibrary.Lisp_Object Lisp_Object1);
	/// Undefined type
	/// Undefined type
	public static interface Lisp_Object {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface EMACS_INT {
		
	};
}
