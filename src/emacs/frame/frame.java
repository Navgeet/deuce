package emacs.frame;
import emacs.frame.FrameLibrary.font_data_list;
import emacs.frame.FrameLibrary.font_driver_list;
import emacs.frame.FrameLibrary.fullscreen_type;
import emacs.frame.FrameLibrary.ns_output;
import emacs.frame.FrameLibrary.output_method;
import emacs.frame.FrameLibrary.terminal;
import emacs.frame.FrameLibrary.text_cursor_kinds;
import emacs.frame.FrameLibrary.tty_output;
import emacs.frame.FrameLibrary.vertical_scroll_bar_type;
import emacs.frame.FrameLibrary.w32_output;
import emacs.frame.FrameLibrary.x_output;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Array;
import org.bridj.ann.Bits;
import org.bridj.ann.CLong;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
import org.bridj.ann.Union;
/**
 * <i>native declaration : frame.h:2508</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("frame") 
public class frame extends StructObject {
	public frame() {
		super();
	}
	/**
	 * Cache of realized faces.<br>
	 * C type : face_cache*
	 */
	@Field(23) 
	public Pointer<face_cache > face_cache() {
		return this.io.getPointerField(this, 23);
	}
	/**
	 * Cache of realized faces.<br>
	 * C type : face_cache*
	 */
	@Field(23) 
	public frame face_cache(Pointer<face_cache > face_cache) {
		this.io.setPointerField(this, 23, face_cache);
		return this;
	}
	/// Number of elements in `menu_bar_vector' that have meaningful data.
	@Field(24) 
	public int menu_bar_items_used() {
		return this.io.getIntField(this, 24);
	}
	/// Number of elements in `menu_bar_vector' that have meaningful data.
	@Field(24) 
	public frame menu_bar_items_used(int menu_bar_items_used) {
		this.io.setIntField(this, 24, menu_bar_items_used);
		return this;
	}
	/**
	 * A buffer to hold the frame's name.  We can't use the Lisp<br>
	 * string's pointer (`name', above) because it might get relocated.<br>
	 * C type : char*
	 */
	@Field(25) 
	public Pointer<Byte > namebuf() {
		return this.io.getPointerField(this, 25);
	}
	/**
	 * A buffer to hold the frame's name.  We can't use the Lisp<br>
	 * string's pointer (`name', above) because it might get relocated.<br>
	 * C type : char*
	 */
	@Field(25) 
	public frame namebuf(Pointer<Byte > namebuf) {
		this.io.setPointerField(this, 25, namebuf);
		return this;
	}
	/**
	 * Glyph pool and matrix.<br>
	 * C type : glyph_pool*
	 */
	@Field(26) 
	public Pointer<glyph_pool > current_pool() {
		return this.io.getPointerField(this, 26);
	}
	/**
	 * Glyph pool and matrix.<br>
	 * C type : glyph_pool*
	 */
	@Field(26) 
	public frame current_pool(Pointer<glyph_pool > current_pool) {
		this.io.setPointerField(this, 26, current_pool);
		return this;
	}
	/// C type : glyph_pool*
	@Field(27) 
	public Pointer<glyph_pool > desired_pool() {
		return this.io.getPointerField(this, 27);
	}
	/// C type : glyph_pool*
	@Field(27) 
	public frame desired_pool(Pointer<glyph_pool > desired_pool) {
		this.io.setPointerField(this, 27, desired_pool);
		return this;
	}
	/// C type : glyph_matrix*
	@Field(28) 
	public Pointer<glyph_matrix > desired_matrix() {
		return this.io.getPointerField(this, 28);
	}
	/// C type : glyph_matrix*
	@Field(28) 
	public frame desired_matrix(Pointer<glyph_matrix > desired_matrix) {
		this.io.setPointerField(this, 28, desired_matrix);
		return this;
	}
	/// C type : glyph_matrix*
	@Field(29) 
	public Pointer<glyph_matrix > current_matrix() {
		return this.io.getPointerField(this, 29);
	}
	/// C type : glyph_matrix*
	@Field(29) 
	public frame current_matrix(Pointer<glyph_matrix > current_matrix) {
		this.io.setPointerField(this, 29, current_matrix);
		return this;
	}
	/**
	 * 1 means that glyphs on this frame have been initialized so it can<br>
	 * be used for output.
	 */
	@Field(30) 
	@Bits(1) 
	public int glyphs_initialized_p() {
		return this.io.getIntField(this, 30);
	}
	/**
	 * 1 means that glyphs on this frame have been initialized so it can<br>
	 * be used for output.
	 */
	@Field(30) 
	@Bits(1) 
	public frame glyphs_initialized_p(int glyphs_initialized_p) {
		this.io.setIntField(this, 30, glyphs_initialized_p);
		return this;
	}
	/**
	 * Set to non-zero in change_frame_size when size of frame changed<br>
	 * Clear the frame in clear_garbaged_frames if set.
	 */
	@Field(31) 
	@Bits(1) 
	public int resized_p() {
		return this.io.getIntField(this, 31);
	}
	/**
	 * Set to non-zero in change_frame_size when size of frame changed<br>
	 * Clear the frame in clear_garbaged_frames if set.
	 */
	@Field(31) 
	@Bits(1) 
	public frame resized_p(int resized_p) {
		this.io.setIntField(this, 31, resized_p);
		return this;
	}
	/**
	 * Set to non-zero in when we want for force a flush_display in<br>
	 * update_frame, usually after resizing the frame.
	 */
	@Field(32) 
	@Bits(1) 
	public int force_flush_display_p() {
		return this.io.getIntField(this, 32);
	}
	/**
	 * Set to non-zero in when we want for force a flush_display in<br>
	 * update_frame, usually after resizing the frame.
	 */
	@Field(32) 
	@Bits(1) 
	public frame force_flush_display_p(int force_flush_display_p) {
		this.io.setIntField(this, 32, force_flush_display_p);
		return this;
	}
	/**
	 * Set to non-zero if the default face for the frame has been<br>
	 * realized.  Reset to zero whenever the default face changes.<br>
	 * Used to see the difference between a font change and face change.
	 */
	@Field(33) 
	@Bits(1) 
	public int default_face_done_p() {
		return this.io.getIntField(this, 33);
	}
	/**
	 * Set to non-zero if the default face for the frame has been<br>
	 * realized.  Reset to zero whenever the default face changes.<br>
	 * Used to see the difference between a font change and face change.
	 */
	@Field(33) 
	@Bits(1) 
	public frame default_face_done_p(int default_face_done_p) {
		this.io.setIntField(this, 33, default_face_done_p);
		return this;
	}
	/**
	 * Set to non-zero if this frame has already been hscrolled during<br>
	 * current redisplay.
	 */
	@Field(34) 
	@Bits(1) 
	public int already_hscrolled_p() {
		return this.io.getIntField(this, 34);
	}
	/**
	 * Set to non-zero if this frame has already been hscrolled during<br>
	 * current redisplay.
	 */
	@Field(34) 
	@Bits(1) 
	public frame already_hscrolled_p(int already_hscrolled_p) {
		this.io.setIntField(this, 34, already_hscrolled_p);
		return this;
	}
	/// Set to non-zero when current redisplay has updated frame.
	@Field(35) 
	@Bits(1) 
	public int updated_p() {
		return this.io.getIntField(this, 35);
	}
	/// Set to non-zero when current redisplay has updated frame.
	@Field(35) 
	@Bits(1) 
	public frame updated_p(int updated_p) {
		this.io.setIntField(this, 35, updated_p);
		return this;
	}
	/**
	 * Set to non-zero to minimize tool-bar height even when<br>
	 * auto-resize-tool-bar is set to grow-only.
	 */
	@Field(36) 
	@Bits(1) 
	public int minimize_tool_bar_window_p() {
		return this.io.getIntField(this, 36);
	}
	/**
	 * Set to non-zero to minimize tool-bar height even when<br>
	 * auto-resize-tool-bar is set to grow-only.
	 */
	@Field(36) 
	@Bits(1) 
	public frame minimize_tool_bar_window_p(int minimize_tool_bar_window_p) {
		this.io.setIntField(this, 36, minimize_tool_bar_window_p);
		return this;
	}
	/// Margin at the top of the frame.  Used to display the tool-bar.
	@Field(37) 
	public int tool_bar_lines() {
		return this.io.getIntField(this, 37);
	}
	/// Margin at the top of the frame.  Used to display the tool-bar.
	@Field(37) 
	public frame tool_bar_lines(int tool_bar_lines) {
		this.io.setIntField(this, 37, tool_bar_lines);
		return this;
	}
	@Field(38) 
	public int n_tool_bar_rows() {
		return this.io.getIntField(this, 38);
	}
	@Field(38) 
	public frame n_tool_bar_rows(int n_tool_bar_rows) {
		this.io.setIntField(this, 38, n_tool_bar_rows);
		return this;
	}
	@Field(39) 
	public int n_tool_bar_items() {
		return this.io.getIntField(this, 39);
	}
	@Field(39) 
	public frame n_tool_bar_items(int n_tool_bar_items) {
		this.io.setIntField(this, 39, n_tool_bar_items);
		return this;
	}
	/**
	 * A buffer for decode_mode_line.<br>
	 * C type : char*
	 */
	@Field(40) 
	public Pointer<Byte > decode_mode_spec_buffer() {
		return this.io.getPointerField(this, 40);
	}
	/**
	 * A buffer for decode_mode_line.<br>
	 * C type : char*
	 */
	@Field(40) 
	public frame decode_mode_spec_buffer(Pointer<Byte > decode_mode_spec_buffer) {
		this.io.setPointerField(this, 40, decode_mode_spec_buffer);
		return this;
	}
	/**
	 * Cost of inserting 1 line on this frame<br>
	 * C type : int*
	 */
	@Field(41) 
	public Pointer<Integer > insert_line_cost() {
		return this.io.getPointerField(this, 41);
	}
	/**
	 * Cost of inserting 1 line on this frame<br>
	 * C type : int*
	 */
	@Field(41) 
	public frame insert_line_cost(Pointer<Integer > insert_line_cost) {
		this.io.setPointerField(this, 41, insert_line_cost);
		return this;
	}
	/**
	 * Cost of deleting 1 line on this frame<br>
	 * C type : int*
	 */
	@Field(42) 
	public Pointer<Integer > delete_line_cost() {
		return this.io.getPointerField(this, 42);
	}
	/**
	 * Cost of deleting 1 line on this frame<br>
	 * C type : int*
	 */
	@Field(42) 
	public frame delete_line_cost(Pointer<Integer > delete_line_cost) {
		this.io.setPointerField(this, 42, delete_line_cost);
		return this;
	}
	/**
	 * Cost of inserting n lines on this frame<br>
	 * C type : int*
	 */
	@Field(43) 
	public Pointer<Integer > insert_n_lines_cost() {
		return this.io.getPointerField(this, 43);
	}
	/**
	 * Cost of inserting n lines on this frame<br>
	 * C type : int*
	 */
	@Field(43) 
	public frame insert_n_lines_cost(Pointer<Integer > insert_n_lines_cost) {
		this.io.setPointerField(this, 43, insert_n_lines_cost);
		return this;
	}
	/**
	 * Cost of deleting n lines on this frame<br>
	 * C type : int*
	 */
	@Field(44) 
	public Pointer<Integer > delete_n_lines_cost() {
		return this.io.getPointerField(this, 44);
	}
	/**
	 * Cost of deleting n lines on this frame<br>
	 * C type : int*
	 */
	@Field(44) 
	public frame delete_n_lines_cost(Pointer<Integer > delete_n_lines_cost) {
		this.io.setPointerField(this, 44, delete_n_lines_cost);
		return this;
	}
	/**
	 * Size of this frame, excluding fringes, scroll bars etc.,<br>
	 * in units of canonical characters.
	 */
	@Field(45) 
	public int text_lines() {
		return this.io.getIntField(this, 45);
	}
	/**
	 * Size of this frame, excluding fringes, scroll bars etc.,<br>
	 * in units of canonical characters.
	 */
	@Field(45) 
	public frame text_lines(int text_lines) {
		this.io.setIntField(this, 45, text_lines);
		return this;
	}
	/**
	 * Size of this frame, excluding fringes, scroll bars etc.,<br>
	 * in units of canonical characters.
	 */
	@Field(46) 
	public int text_cols() {
		return this.io.getIntField(this, 46);
	}
	/**
	 * Size of this frame, excluding fringes, scroll bars etc.,<br>
	 * in units of canonical characters.
	 */
	@Field(46) 
	public frame text_cols(int text_cols) {
		this.io.setIntField(this, 46, text_cols);
		return this;
	}
	/**
	 * Total size of this frame (i.e. its native window), in units of<br>
	 * canonical characters.
	 */
	@Field(47) 
	public int total_lines() {
		return this.io.getIntField(this, 47);
	}
	/**
	 * Total size of this frame (i.e. its native window), in units of<br>
	 * canonical characters.
	 */
	@Field(47) 
	public frame total_lines(int total_lines) {
		this.io.setIntField(this, 47, total_lines);
		return this;
	}
	/**
	 * Total size of this frame (i.e. its native window), in units of<br>
	 * canonical characters.
	 */
	@Field(48) 
	public int total_cols() {
		return this.io.getIntField(this, 48);
	}
	/**
	 * Total size of this frame (i.e. its native window), in units of<br>
	 * canonical characters.
	 */
	@Field(48) 
	public frame total_cols(int total_cols) {
		this.io.setIntField(this, 48, total_cols);
		return this;
	}
	/**
	 * New text height and width for pending size change.<br>
	 * 0 if no change pending.
	 */
	@Field(49) 
	public int new_text_lines() {
		return this.io.getIntField(this, 49);
	}
	/**
	 * New text height and width for pending size change.<br>
	 * 0 if no change pending.
	 */
	@Field(49) 
	public frame new_text_lines(int new_text_lines) {
		this.io.setIntField(this, 49, new_text_lines);
		return this;
	}
	/**
	 * New text height and width for pending size change.<br>
	 * 0 if no change pending.
	 */
	@Field(50) 
	public int new_text_cols() {
		return this.io.getIntField(this, 50);
	}
	/**
	 * New text height and width for pending size change.<br>
	 * 0 if no change pending.
	 */
	@Field(50) 
	public frame new_text_cols(int new_text_cols) {
		this.io.setIntField(this, 50, new_text_cols);
		return this;
	}
	/// Pixel position of the frame window (x and y offsets in root window).
	@Field(51) 
	public int left_pos() {
		return this.io.getIntField(this, 51);
	}
	/// Pixel position of the frame window (x and y offsets in root window).
	@Field(51) 
	public frame left_pos(int left_pos) {
		this.io.setIntField(this, 51, left_pos);
		return this;
	}
	/// Pixel position of the frame window (x and y offsets in root window).
	@Field(52) 
	public int top_pos() {
		return this.io.getIntField(this, 52);
	}
	/// Pixel position of the frame window (x and y offsets in root window).
	@Field(52) 
	public frame top_pos(int top_pos) {
		this.io.setIntField(this, 52, top_pos);
		return this;
	}
	/// Size of the frame window in pixels.
	@Field(53) 
	public int pixel_height() {
		return this.io.getIntField(this, 53);
	}
	/// Size of the frame window in pixels.
	@Field(53) 
	public frame pixel_height(int pixel_height) {
		this.io.setIntField(this, 53, pixel_height);
		return this;
	}
	/// Size of the frame window in pixels.
	@Field(54) 
	public int pixel_width() {
		return this.io.getIntField(this, 54);
	}
	/// Size of the frame window in pixels.
	@Field(54) 
	public frame pixel_width(int pixel_width) {
		this.io.setIntField(this, 54, pixel_width);
		return this;
	}
	/// Dots per inch of the screen the frame is on.
	@Field(55) 
	public double resx() {
		return this.io.getDoubleField(this, 55);
	}
	/// Dots per inch of the screen the frame is on.
	@Field(55) 
	public frame resx(double resx) {
		this.io.setDoubleField(this, 55, resx);
		return this;
	}
	/// Dots per inch of the screen the frame is on.
	@Field(56) 
	public double resy() {
		return this.io.getDoubleField(this, 56);
	}
	/// Dots per inch of the screen the frame is on.
	@Field(56) 
	public frame resy(double resy) {
		this.io.setDoubleField(this, 56, resy);
		return this;
	}
	/**
	 * These many pixels are the difference between the outer window (i.e. the<br>
	 * left and top of the window manager decoration) and FRAME_X_WINDOW.
	 */
	@Field(57) 
	public int x_pixels_diff() {
		return this.io.getIntField(this, 57);
	}
	/**
	 * These many pixels are the difference between the outer window (i.e. the<br>
	 * left and top of the window manager decoration) and FRAME_X_WINDOW.
	 */
	@Field(57) 
	public frame x_pixels_diff(int x_pixels_diff) {
		this.io.setIntField(this, 57, x_pixels_diff);
		return this;
	}
	/**
	 * These many pixels are the difference between the outer window (i.e. the<br>
	 * left and top of the window manager decoration) and FRAME_X_WINDOW.
	 */
	@Field(58) 
	public int y_pixels_diff() {
		return this.io.getIntField(this, 58);
	}
	/**
	 * These many pixels are the difference between the outer window (i.e. the<br>
	 * left and top of the window manager decoration) and FRAME_X_WINDOW.
	 */
	@Field(58) 
	public frame y_pixels_diff(int y_pixels_diff) {
		this.io.setIntField(this, 58, y_pixels_diff);
		return this;
	}
	/// This is the gravity value for the specified window position.
	@Field(59) 
	public int win_gravity() {
		return this.io.getIntField(this, 59);
	}
	/// This is the gravity value for the specified window position.
	@Field(59) 
	public frame win_gravity(int win_gravity) {
		this.io.setIntField(this, 59, win_gravity);
		return this;
	}
	/// The geometry flags for this window.
	@Field(60) 
	public int size_hint_flags() {
		return this.io.getIntField(this, 60);
	}
	/// The geometry flags for this window.
	@Field(60) 
	public frame size_hint_flags(int size_hint_flags) {
		this.io.setIntField(this, 60, size_hint_flags);
		return this;
	}
	/// Border width of the frame window as known by the (X) window system.
	@Field(61) 
	public int border_width() {
		return this.io.getIntField(this, 61);
	}
	/// Border width of the frame window as known by the (X) window system.
	@Field(61) 
	public frame border_width(int border_width) {
		this.io.setIntField(this, 61, border_width);
		return this;
	}
	/**
	 * Width of the internal border.  This is a line of background color<br>
	 * just inside the window's border.  When the frame is selected,<br>
	 * a highlighting is displayed inside the internal border.
	 */
	@Field(62) 
	public int internal_border_width() {
		return this.io.getIntField(this, 62);
	}
	/**
	 * Width of the internal border.  This is a line of background color<br>
	 * just inside the window's border.  When the frame is selected,<br>
	 * a highlighting is displayed inside the internal border.
	 */
	@Field(62) 
	public frame internal_border_width(int internal_border_width) {
		this.io.setIntField(this, 62, internal_border_width);
		return this;
	}
	/// Canonical X unit.  Width of default font, in pixels.
	@Field(63) 
	public int column_width() {
		return this.io.getIntField(this, 63);
	}
	/// Canonical X unit.  Width of default font, in pixels.
	@Field(63) 
	public frame column_width(int column_width) {
		this.io.setIntField(this, 63, column_width);
		return this;
	}
	/// Width of space glyph of default font, in pixels.
	@Field(64) 
	public int space_width() {
		return this.io.getIntField(this, 64);
	}
	/// Width of space glyph of default font, in pixels.
	@Field(64) 
	public frame space_width(int space_width) {
		this.io.setIntField(this, 64, space_width);
		return this;
	}
	/// Canonical Y unit.  Height of a line, in pixels.
	@Field(65) 
	public int line_height() {
		return this.io.getIntField(this, 65);
	}
	/// Canonical Y unit.  Height of a line, in pixels.
	@Field(65) 
	public frame line_height(int line_height) {
		this.io.setIntField(this, 65, line_height);
		return this;
	}
	/**
	 * The output method says how the contents of this frame are<br>
	 * displayed.  It could be using termcap, or using an X window.<br>
	 * This must be the same as the terminal->type.<br>
	 * C type : output_method
	 */
	@Field(66) 
	public IntValuedEnum<output_method > output_method() {
		return this.io.getEnumField(this, 66);
	}
	/**
	 * The output method says how the contents of this frame are<br>
	 * displayed.  It could be using termcap, or using an X window.<br>
	 * This must be the same as the terminal->type.<br>
	 * C type : output_method
	 */
	@Field(66) 
	public frame output_method(IntValuedEnum<output_method > output_method) {
		this.io.setEnumField(this, 66, output_method);
		return this;
	}
	/**
	 * The terminal device that this frame uses.  If this is NULL, then<br>
	 * the frame has been deleted.<br>
	 * C type : terminal*
	 */
	@Field(67) 
	public Pointer<terminal > terminal() {
		return this.io.getPointerField(this, 67);
	}
	/**
	 * The terminal device that this frame uses.  If this is NULL, then<br>
	 * the frame has been deleted.<br>
	 * C type : terminal*
	 */
	@Field(67) 
	public frame terminal(Pointer<terminal > terminal) {
		this.io.setPointerField(this, 67, terminal);
		return this;
	}
	/**
	 * Device-dependent, frame-local auxiliary data used for displaying<br>
	 * the contents.  When the frame is deleted, this data is deleted as<br>
	 * well.<br>
	 * C type : output_data
	 */
	@Field(68) 
	public frame.output_data output_data() {
		return this.io.getNativeObjectField(this, 68);
	}
	/**
	 * Device-dependent, frame-local auxiliary data used for displaying<br>
	 * the contents.  When the frame is deleted, this data is deleted as<br>
	 * well.<br>
	 * C type : output_data
	 */
	@Field(68) 
	public frame output_data(frame.output_data output_data) {
		this.io.setNativeObjectField(this, 68, output_data);
		return this;
	}
	/**
	 * List of font-drivers available on the frame.<br>
	 * C type : font_driver_list*
	 */
	@Field(69) 
	public Pointer<font_driver_list > font_driver_list() {
		return this.io.getPointerField(this, 69);
	}
	/**
	 * List of font-drivers available on the frame.<br>
	 * C type : font_driver_list*
	 */
	@Field(69) 
	public frame font_driver_list(Pointer<font_driver_list > font_driver_list) {
		this.io.setPointerField(this, 69, font_driver_list);
		return this;
	}
	/**
	 * List of data specific to font-driver and frame, but common to<br>
	 * faces.<br>
	 * C type : font_data_list*
	 */
	@Field(70) 
	public Pointer<font_data_list > font_data_list() {
		return this.io.getPointerField(this, 70);
	}
	/**
	 * List of data specific to font-driver and frame, but common to<br>
	 * faces.<br>
	 * C type : font_data_list*
	 */
	@Field(70) 
	public frame font_data_list(Pointer<font_data_list > font_data_list) {
		this.io.setPointerField(this, 70, font_data_list);
		return this;
	}
	/**
	 * Total width of fringes reserved for drawing truncation bitmaps,<br>
	 * continuation bitmaps and alike.  The width is in canonical char<br>
	 * units of the frame.  This must currently be the case because window<br>
	 * sizes aren't pixel values.  If it weren't the case, we wouldn't be<br>
	 * able to split windows horizontally nicely.
	 */
	@Field(71) 
	public int fringe_cols() {
		return this.io.getIntField(this, 71);
	}
	/**
	 * Total width of fringes reserved for drawing truncation bitmaps,<br>
	 * continuation bitmaps and alike.  The width is in canonical char<br>
	 * units of the frame.  This must currently be the case because window<br>
	 * sizes aren't pixel values.  If it weren't the case, we wouldn't be<br>
	 * able to split windows horizontally nicely.
	 */
	@Field(71) 
	public frame fringe_cols(int fringe_cols) {
		this.io.setIntField(this, 71, fringe_cols);
		return this;
	}
	/// The extra width (in pixels) currently allotted for fringes.
	@Field(72) 
	public int left_fringe_width() {
		return this.io.getIntField(this, 72);
	}
	/// The extra width (in pixels) currently allotted for fringes.
	@Field(72) 
	public frame left_fringe_width(int left_fringe_width) {
		this.io.setIntField(this, 72, left_fringe_width);
		return this;
	}
	/// The extra width (in pixels) currently allotted for fringes.
	@Field(73) 
	public int right_fringe_width() {
		return this.io.getIntField(this, 73);
	}
	/// The extra width (in pixels) currently allotted for fringes.
	@Field(73) 
	public frame right_fringe_width(int right_fringe_width) {
		this.io.setIntField(this, 73, right_fringe_width);
		return this;
	}
	/**
	 * See FULLSCREEN_ enum below<br>
	 * C type : fullscreen_type
	 */
	@Field(74) 
	public IntValuedEnum<fullscreen_type > want_fullscreen() {
		return this.io.getEnumField(this, 74);
	}
	/**
	 * See FULLSCREEN_ enum below<br>
	 * C type : fullscreen_type
	 */
	@Field(74) 
	public frame want_fullscreen(IntValuedEnum<fullscreen_type > want_fullscreen) {
		this.io.setEnumField(this, 74, want_fullscreen);
		return this;
	}
	/// Number of lines of menu bar.
	@Field(75) 
	public int menu_bar_lines() {
		return this.io.getIntField(this, 75);
	}
	/// Number of lines of menu bar.
	@Field(75) 
	public frame menu_bar_lines(int menu_bar_lines) {
		this.io.setIntField(this, 75, menu_bar_lines);
		return this;
	}
	/// Nonzero if last attempt at redisplay on this frame was preempted.
	@Field(76) 
	@Bits(1) 
	public byte display_preempted() {
		return this.io.getByteField(this, 76);
	}
	/// Nonzero if last attempt at redisplay on this frame was preempted.
	@Field(76) 
	@Bits(1) 
	public frame display_preempted(byte display_preempted) {
		this.io.setByteField(this, 76, display_preempted);
		return this;
	}
	/**
	 * visible is nonzero if the frame is currently displayed; we check<br>
	 * it to see if we should bother updating the frame's contents.<br>
	 * DON'T SET IT DIRECTLY; instead, use FRAME_SET_VISIBLE.<br>
	 * Note that, since invisible frames aren't updated, whenever a<br>
	 * frame becomes visible again, it must be marked as garbaged.  The<br>
	 * FRAME_SAMPLE_VISIBILITY macro takes care of this.<br>
	 * On ttys and on Windows NT/9X, to avoid wasting effort updating<br>
	 * visible frames that are actually completely obscured by other<br>
	 * windows on the display, we bend the meaning of visible slightly:<br>
	 * if greater than 1, then the frame is obscured - we still consider<br>
	 * it to be "visible" as seen from lisp, but we don't bother<br>
	 * updating it.  We must take care to garbage the frame when it<br>
	 * ceases to be obscured though.<br>
	 * iconified is nonzero if the frame is currently iconified.<br>
	 * Asynchronous input handlers should NOT change these directly;<br>
	 * instead, they should change async_visible or async_iconified, and<br>
	 * let the FRAME_SAMPLE_VISIBILITY macro set visible and iconified<br>
	 * at the next redisplay.<br>
	 * These should probably be considered read-only by everyone except<br>
	 * FRAME_SAMPLE_VISIBILITY.<br>
	 * These two are mutually exclusive.  They might both be zero, if the<br>
	 * frame has been made invisible without an icon.
	 */
	@Field(77) 
	@Bits(2) 
	public byte visible() {
		return this.io.getByteField(this, 77);
	}
	/**
	 * visible is nonzero if the frame is currently displayed; we check<br>
	 * it to see if we should bother updating the frame's contents.<br>
	 * DON'T SET IT DIRECTLY; instead, use FRAME_SET_VISIBLE.<br>
	 * Note that, since invisible frames aren't updated, whenever a<br>
	 * frame becomes visible again, it must be marked as garbaged.  The<br>
	 * FRAME_SAMPLE_VISIBILITY macro takes care of this.<br>
	 * On ttys and on Windows NT/9X, to avoid wasting effort updating<br>
	 * visible frames that are actually completely obscured by other<br>
	 * windows on the display, we bend the meaning of visible slightly:<br>
	 * if greater than 1, then the frame is obscured - we still consider<br>
	 * it to be "visible" as seen from lisp, but we don't bother<br>
	 * updating it.  We must take care to garbage the frame when it<br>
	 * ceases to be obscured though.<br>
	 * iconified is nonzero if the frame is currently iconified.<br>
	 * Asynchronous input handlers should NOT change these directly;<br>
	 * instead, they should change async_visible or async_iconified, and<br>
	 * let the FRAME_SAMPLE_VISIBILITY macro set visible and iconified<br>
	 * at the next redisplay.<br>
	 * These should probably be considered read-only by everyone except<br>
	 * FRAME_SAMPLE_VISIBILITY.<br>
	 * These two are mutually exclusive.  They might both be zero, if the<br>
	 * frame has been made invisible without an icon.
	 */
	@Field(77) 
	@Bits(2) 
	public frame visible(byte visible) {
		this.io.setByteField(this, 77, visible);
		return this;
	}
	@Field(78) 
	@Bits(1) 
	public byte iconified() {
		return this.io.getByteField(this, 78);
	}
	@Field(78) 
	@Bits(1) 
	public frame iconified(byte iconified) {
		this.io.setByteField(this, 78, iconified);
		return this;
	}
	/**
	 * Asynchronous input handlers change these, and<br>
	 * FRAME_SAMPLE_VISIBILITY copies them into visible and iconified.<br>
	 * See FRAME_SAMPLE_VISIBILITY, below.
	 */
	@Field(79) 
	public byte async_visible() {
		return this.io.getByteField(this, 79);
	}
	/**
	 * Asynchronous input handlers change these, and<br>
	 * FRAME_SAMPLE_VISIBILITY copies them into visible and iconified.<br>
	 * See FRAME_SAMPLE_VISIBILITY, below.
	 */
	@Field(79) 
	public frame async_visible(byte async_visible) {
		this.io.setByteField(this, 79, async_visible);
		return this;
	}
	/**
	 * Asynchronous input handlers change these, and<br>
	 * FRAME_SAMPLE_VISIBILITY copies them into visible and iconified.<br>
	 * See FRAME_SAMPLE_VISIBILITY, below.
	 */
	@Field(80) 
	public byte async_iconified() {
		return this.io.getByteField(this, 80);
	}
	/**
	 * Asynchronous input handlers change these, and<br>
	 * FRAME_SAMPLE_VISIBILITY copies them into visible and iconified.<br>
	 * See FRAME_SAMPLE_VISIBILITY, below.
	 */
	@Field(80) 
	public frame async_iconified(byte async_iconified) {
		this.io.setByteField(this, 80, async_iconified);
		return this;
	}
	/// Nonzero if this frame should be redrawn.
	@Field(81) 
	public byte garbaged() {
		return this.io.getByteField(this, 81);
	}
	/// Nonzero if this frame should be redrawn.
	@Field(81) 
	public frame garbaged(byte garbaged) {
		this.io.setByteField(this, 81, garbaged);
		return this;
	}
	/**
	 * True if frame actually has a minibuffer window on it.<br>
	 * 0 if using a minibuffer window that isn't on this frame.
	 */
	@Field(82) 
	@Bits(1) 
	public byte has_minibuffer() {
		return this.io.getByteField(this, 82);
	}
	/**
	 * True if frame actually has a minibuffer window on it.<br>
	 * 0 if using a minibuffer window that isn't on this frame.
	 */
	@Field(82) 
	@Bits(1) 
	public frame has_minibuffer(byte has_minibuffer) {
		this.io.setByteField(this, 82, has_minibuffer);
		return this;
	}
	/**
	 * 0 means, if this frame has just one window,<br>
	 * show no modeline for that window.
	 */
	@Field(83) 
	@Bits(1) 
	public byte wants_modeline() {
		return this.io.getByteField(this, 83);
	}
	/**
	 * 0 means, if this frame has just one window,<br>
	 * show no modeline for that window.
	 */
	@Field(83) 
	@Bits(1) 
	public frame wants_modeline(byte wants_modeline) {
		this.io.setByteField(this, 83, wants_modeline);
		return this;
	}
	/**
	 * Non-zero if the hardware device this frame is displaying on can<br>
	 * support scroll bars.
	 */
	@Field(84) 
	public byte can_have_scroll_bars() {
		return this.io.getByteField(this, 84);
	}
	/**
	 * Non-zero if the hardware device this frame is displaying on can<br>
	 * support scroll bars.
	 */
	@Field(84) 
	public frame can_have_scroll_bars(byte can_have_scroll_bars) {
		this.io.setByteField(this, 84, can_have_scroll_bars);
		return this;
	}
	/// Non-0 means raise this frame to the top of the heap when selected.
	@Field(85) 
	@Bits(1) 
	public byte auto_raise() {
		return this.io.getByteField(this, 85);
	}
	/// Non-0 means raise this frame to the top of the heap when selected.
	@Field(85) 
	@Bits(1) 
	public frame auto_raise(byte auto_raise) {
		this.io.setByteField(this, 85, auto_raise);
		return this;
	}
	/// Non-0 means lower this frame to the bottom of the stack when left.
	@Field(86) 
	@Bits(1) 
	public byte auto_lower() {
		return this.io.getByteField(this, 86);
	}
	/// Non-0 means lower this frame to the bottom of the stack when left.
	@Field(86) 
	@Bits(1) 
	public frame auto_lower(byte auto_lower) {
		this.io.setByteField(this, 86, auto_lower);
		return this;
	}
	/// True if frame's root window can't be split.
	@Field(87) 
	@Bits(1) 
	public byte no_split() {
		return this.io.getByteField(this, 87);
	}
	/// True if frame's root window can't be split.
	@Field(87) 
	@Bits(1) 
	public frame no_split(byte no_split) {
		this.io.setByteField(this, 87, no_split);
		return this;
	}
	/**
	 * If this is set, then Emacs won't change the frame name to indicate<br>
	 * the current buffer, etcetera.  If the user explicitly sets the frame<br>
	 * name, this gets set.  If the user sets the name to Qnil, this is<br>
	 * cleared.
	 */
	@Field(88) 
	@Bits(1) 
	public byte explicit_name() {
		return this.io.getByteField(this, 88);
	}
	/**
	 * If this is set, then Emacs won't change the frame name to indicate<br>
	 * the current buffer, etcetera.  If the user explicitly sets the frame<br>
	 * name, this gets set.  If the user sets the name to Qnil, this is<br>
	 * cleared.
	 */
	@Field(88) 
	@Bits(1) 
	public frame explicit_name(byte explicit_name) {
		this.io.setByteField(this, 88, explicit_name);
		return this;
	}
	/// Nonzero if size of some window on this frame has changed.
	@Field(89) 
	@Bits(1) 
	public byte window_sizes_changed() {
		return this.io.getByteField(this, 89);
	}
	/// Nonzero if size of some window on this frame has changed.
	@Field(89) 
	@Bits(1) 
	public frame window_sizes_changed(byte window_sizes_changed) {
		this.io.setByteField(this, 89, window_sizes_changed);
		return this;
	}
	/**
	 * Nonzero if the mouse has moved on this display device<br>
	 * since the last time we checked.
	 */
	@Field(90) 
	@Bits(1) 
	public byte mouse_moved() {
		return this.io.getByteField(this, 90);
	}
	/**
	 * Nonzero if the mouse has moved on this display device<br>
	 * since the last time we checked.
	 */
	@Field(90) 
	@Bits(1) 
	public frame mouse_moved(byte mouse_moved) {
		this.io.setByteField(this, 90, mouse_moved);
		return this;
	}
	/// Nonzero means that the pointer is invisible.
	@Field(91) 
	@Bits(1) 
	public byte pointer_invisible() {
		return this.io.getByteField(this, 91);
	}
	/// Nonzero means that the pointer is invisible.
	@Field(91) 
	@Bits(1) 
	public frame pointer_invisible(byte pointer_invisible) {
		this.io.setByteField(this, 91, pointer_invisible);
		return this;
	}
	/**
	 * If can_have_scroll_bars is non-zero, this is non-zero if we should<br>
	 * actually display them on this frame.<br>
	 * C type : vertical_scroll_bar_type
	 */
	@Field(92) 
	public IntValuedEnum<vertical_scroll_bar_type > vertical_scroll_bar_type() {
		return this.io.getEnumField(this, 92);
	}
	/**
	 * If can_have_scroll_bars is non-zero, this is non-zero if we should<br>
	 * actually display them on this frame.<br>
	 * C type : vertical_scroll_bar_type
	 */
	@Field(92) 
	public frame vertical_scroll_bar_type(IntValuedEnum<vertical_scroll_bar_type > vertical_scroll_bar_type) {
		this.io.setEnumField(this, 92, vertical_scroll_bar_type);
		return this;
	}
	/**
	 * What kind of text cursor should we draw in the future?<br>
	 * This should always be filled_box_cursor or bar_cursor.<br>
	 * C type : text_cursor_kinds
	 */
	@Field(93) 
	public IntValuedEnum<text_cursor_kinds > desired_cursor() {
		return this.io.getEnumField(this, 93);
	}
	/**
	 * What kind of text cursor should we draw in the future?<br>
	 * This should always be filled_box_cursor or bar_cursor.<br>
	 * C type : text_cursor_kinds
	 */
	@Field(93) 
	public frame desired_cursor(IntValuedEnum<text_cursor_kinds > desired_cursor) {
		this.io.setEnumField(this, 93, desired_cursor);
		return this;
	}
	/// Width of bar cursor (if we are using that).
	@Field(94) 
	public int cursor_width() {
		return this.io.getIntField(this, 94);
	}
	/// Width of bar cursor (if we are using that).
	@Field(94) 
	public frame cursor_width(int cursor_width) {
		this.io.setIntField(this, 94, cursor_width);
		return this;
	}
	/**
	 * What kind of text cursor should we draw when the cursor blinks off?<br>
	 * This can be filled_box_cursor or bar_cursor or no_cursor.<br>
	 * C type : text_cursor_kinds
	 */
	@Field(95) 
	public IntValuedEnum<text_cursor_kinds > blink_off_cursor() {
		return this.io.getEnumField(this, 95);
	}
	/**
	 * What kind of text cursor should we draw when the cursor blinks off?<br>
	 * This can be filled_box_cursor or bar_cursor or no_cursor.<br>
	 * C type : text_cursor_kinds
	 */
	@Field(95) 
	public frame blink_off_cursor(IntValuedEnum<text_cursor_kinds > blink_off_cursor) {
		this.io.setEnumField(this, 95, blink_off_cursor);
		return this;
	}
	/// Width of bar cursor (if we are using that) for blink-off state.
	@Field(96) 
	public int blink_off_cursor_width() {
		return this.io.getIntField(this, 96);
	}
	/// Width of bar cursor (if we are using that) for blink-off state.
	@Field(96) 
	public frame blink_off_cursor_width(int blink_off_cursor_width) {
		this.io.setIntField(this, 96, blink_off_cursor_width);
		return this;
	}
	/**
	 * Storage for messages to this frame.<br>
	 * C type : char*
	 */
	@Field(97) 
	public Pointer<Byte > message_buf() {
		return this.io.getPointerField(this, 97);
	}
	/**
	 * Storage for messages to this frame.<br>
	 * C type : char*
	 */
	@Field(97) 
	public frame message_buf(Pointer<Byte > message_buf) {
		this.io.setPointerField(this, 97, message_buf);
		return this;
	}
	/**
	 * Nonnegative if current redisplay should not do scroll computation<br>
	 * for lines beyond a certain vpos.  This is the vpos.
	 */
	@Field(98) 
	public int scroll_bottom_vpos() {
		return this.io.getIntField(this, 98);
	}
	/**
	 * Nonnegative if current redisplay should not do scroll computation<br>
	 * for lines beyond a certain vpos.  This is the vpos.
	 */
	@Field(98) 
	public frame scroll_bottom_vpos(int scroll_bottom_vpos) {
		this.io.setIntField(this, 98, scroll_bottom_vpos);
		return this;
	}
	/**
	 * Configured width of the scroll bar, in pixels and in characters.<br>
	 * config_scroll_bar_cols tracks config_scroll_bar_width if the<br>
	 * latter is positive; a zero value in config_scroll_bar_width means<br>
	 * to compute the actual width on the fly, using config_scroll_bar_cols<br>
	 * and the current font width.
	 */
	@Field(99) 
	public int config_scroll_bar_width() {
		return this.io.getIntField(this, 99);
	}
	/**
	 * Configured width of the scroll bar, in pixels and in characters.<br>
	 * config_scroll_bar_cols tracks config_scroll_bar_width if the<br>
	 * latter is positive; a zero value in config_scroll_bar_width means<br>
	 * to compute the actual width on the fly, using config_scroll_bar_cols<br>
	 * and the current font width.
	 */
	@Field(99) 
	public frame config_scroll_bar_width(int config_scroll_bar_width) {
		this.io.setIntField(this, 99, config_scroll_bar_width);
		return this;
	}
	@Field(100) 
	public int config_scroll_bar_cols() {
		return this.io.getIntField(this, 100);
	}
	@Field(100) 
	public frame config_scroll_bar_cols(int config_scroll_bar_cols) {
		this.io.setIntField(this, 100, config_scroll_bar_cols);
		return this;
	}
	/**
	 * The size of the extra width currently allotted for vertical<br>
	 * scroll bars in this frame, in pixels.
	 */
	@Field(101) 
	public int scroll_bar_actual_width() {
		return this.io.getIntField(this, 101);
	}
	/**
	 * The size of the extra width currently allotted for vertical<br>
	 * scroll bars in this frame, in pixels.
	 */
	@Field(101) 
	public frame scroll_bar_actual_width(int scroll_bar_actual_width) {
		this.io.setIntField(this, 101, scroll_bar_actual_width);
		return this;
	}
	/// The baud rate that was used to calculate costs for this frame.
	@Field(102) 
	public int cost_calculation_baud_rate() {
		return this.io.getIntField(this, 102);
	}
	/// The baud rate that was used to calculate costs for this frame.
	@Field(102) 
	public frame cost_calculation_baud_rate(int cost_calculation_baud_rate) {
		this.io.setIntField(this, 102, cost_calculation_baud_rate);
		return this;
	}
	/**
	 * frame opacity<br>
	 * alpha[0]: alpha transparency of the active frame<br>
	 * alpha[1]: alpha transparency of inactive frames<br>
	 * Negative values mean not to change alpha.<br>
	 * C type : double[2]
	 */
	@Array({2}) 
	@Field(103) 
	public Pointer<Double > alpha() {
		return this.io.getPointerField(this, 103);
	}
	/**
	 * Exponent for gamma correction of colors.  1/(VIEWING_GAMMA *<br>
	 * SCREEN_GAMMA) where viewing_gamma is 0.4545 and SCREEN_GAMMA is a<br>
	 * frame parameter.  0 means don't do gamma correction.
	 */
	@Field(104) 
	public double gamma() {
		return this.io.getDoubleField(this, 104);
	}
	/**
	 * Exponent for gamma correction of colors.  1/(VIEWING_GAMMA *<br>
	 * SCREEN_GAMMA) where viewing_gamma is 0.4545 and SCREEN_GAMMA is a<br>
	 * frame parameter.  0 means don't do gamma correction.
	 */
	@Field(104) 
	public frame gamma(double gamma) {
		this.io.setDoubleField(this, 104, gamma);
		return this;
	}
	/// Additional space to put between text lines on this frame.
	@Field(105) 
	public int extra_line_spacing() {
		return this.io.getIntField(this, 105);
	}
	/// Additional space to put between text lines on this frame.
	@Field(105) 
	public frame extra_line_spacing(int extra_line_spacing) {
		this.io.setIntField(this, 105, extra_line_spacing);
		return this;
	}
	/// All display backends seem to need these two pixel values.
	@CLong 
	@Field(106) 
	public long background_pixel() {
		return this.io.getCLongField(this, 106);
	}
	/// All display backends seem to need these two pixel values.
	@CLong 
	@Field(106) 
	public frame background_pixel(long background_pixel) {
		this.io.setCLongField(this, 106, background_pixel);
		return this;
	}
	@CLong 
	@Field(107) 
	public long foreground_pixel() {
		return this.io.getCLongField(this, 107);
	}
	@CLong 
	@Field(107) 
	public frame foreground_pixel(long foreground_pixel) {
		this.io.setCLongField(this, 107, foreground_pixel);
		return this;
	}
	/// <i>native declaration : frame.h:2499</i>
	/// <i>native declaration : frame.h:2499</i>
	@Union 
	public static class output_data extends StructObject {
		public output_data() {
			super();
		}
		/**
		 * termchar.h<br>
		 * C type : tty_output*
		 */
		@Field(0) 
		public Pointer<tty_output > tty() {
			return this.io.getPointerField(this, 0);
		}
		/**
		 * termchar.h<br>
		 * C type : tty_output*
		 */
		@Field(0) 
		public output_data tty(Pointer<tty_output > tty) {
			this.io.setPointerField(this, 0, tty);
			return this;
		}
		/**
		 * xterm.h<br>
		 * C type : x_output*
		 */
		@Field(1) 
		public Pointer<x_output > x() {
			return this.io.getPointerField(this, 1);
		}
		/**
		 * xterm.h<br>
		 * C type : x_output*
		 */
		@Field(1) 
		public output_data x(Pointer<x_output > x) {
			this.io.setPointerField(this, 1, x);
			return this;
		}
		/**
		 * w32term.h<br>
		 * C type : w32_output*
		 */
		@Field(2) 
		public Pointer<w32_output > w32() {
			return this.io.getPointerField(this, 2);
		}
		/**
		 * w32term.h<br>
		 * C type : w32_output*
		 */
		@Field(2) 
		public output_data w32(Pointer<w32_output > w32) {
			this.io.setPointerField(this, 2, w32);
			return this;
		}
		/**
		 * nsterm.h<br>
		 * C type : ns_output*
		 */
		@Field(3) 
		public Pointer<ns_output > ns() {
			return this.io.getPointerField(this, 3);
		}
		/**
		 * nsterm.h<br>
		 * C type : ns_output*
		 */
		@Field(3) 
		public output_data ns(Pointer<ns_output > ns) {
			this.io.setPointerField(this, 3, ns);
			return this;
		}
	};
}
