package emacs.termhooks;
import java.util.Collections;
import java.util.Iterator;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Runtime;
import org.bridj.util.DefaultParameterizedType;
/**
 * Wrapper for library <b>termhooks</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("termhooks") 
@Runtime(CRuntime.class) 
public class TermhooksLibrary {
	static {
		BridJ.register();
	}
	/**
	 * enum values<br>
	 * <i>native declaration : termhooks.h:321</i>
	 */
	public enum scroll_bar_part implements IntValuedEnum<scroll_bar_part > {
		scroll_bar_above_handle(0),
		scroll_bar_handle(1),
		scroll_bar_below_handle(2),
		scroll_bar_up_arrow(3),
		scroll_bar_down_arrow(4),
		scroll_bar_to_top(5),
		scroll_bar_to_bottom(6),
		scroll_bar_end_scroll(7),
		scroll_bar_move_ratio(8);
		scroll_bar_part(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<scroll_bar_part > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<scroll_bar_part > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * enum values<br>
	 * <i>native declaration : termhooks.h:449</i>
	 */
	public enum event_kind implements IntValuedEnum<event_kind > {
		/**
		 * nothing happened.  This should never<br>
		 * actually appear in the event queue.
		 */
		NO_EVENT(0),
		/**
		 * The ASCII code is in .code, perhaps<br>
		 * with modifiers applied.<br>
		 * .modifiers holds the state of the<br>
		 * modifier keys.<br>
		 * .frame_or_window is the frame in<br>
		 * which the key was typed.<br>
		 * .timestamp gives a timestamp (in<br>
		 * milliseconds) for the keystroke.
		 */
		ASCII_KEYSTROKE_EVENT(1),
		/**
		 * The multibyte char code is in .code,<br>
		 * perhaps with modifiers applied.<br>
		 * The others are the same as<br>
		 * ASCII_KEYSTROKE_EVENT.
		 */
		MULTIBYTE_CHAR_KEYSTROKE_EVENT(2),
		/**
		 * .code is a number identifying the<br>
		 * function key.  A code N represents<br>
		 * a key whose name is<br>
		 * function_key_names[N]; function_key_names<br>
		 * is a table in keyboard.c to which you<br>
		 * should feel free to add missing keys.<br>
		 * .modifiers holds the state of the<br>
		 * modifier keys.<br>
		 * .frame_or_window is the frame in<br>
		 * which the key was typed.<br>
		 * .timestamp gives a timestamp (in<br>
		 * milliseconds) for the keystroke.
		 */
		NON_ASCII_KEYSTROKE_EVENT(3),
		/// A timer fired.
		TIMER_EVENT(4),
		/**
		 * The button number is in .code; it must<br>
		 * be >= 0 and < NUM_MOUSE_BUTTONS, defined<br>
		 * below.<br>
		 * .modifiers holds the state of the<br>
		 * modifier keys.<br>
		 * .x and .y give the mouse position,<br>
		 * in characters, within the window.<br>
		 * .frame_or_window gives the frame<br>
		 * the mouse click occurred in.<br>
		 * .timestamp gives a timestamp (in<br>
		 * milliseconds) for the click.
		 */
		MOUSE_CLICK_EVENT(5),
		/**
		 * A wheel event is generated by a<br>
		 * wheel on a mouse (e.g., MS<br>
		 * Intellimouse).<br>
		 * .modifiers holds the rotate<br>
		 * direction (up or down), and the<br>
		 * state of the modifier keys.<br>
		 * .x and .y give the mouse position,<br>
		 * in characters, within the window.<br>
		 * .frame_or_window gives the frame<br>
		 * the wheel event occurred in.<br>
		 * .timestamp gives a timestamp (in<br>
		 * milliseconds) for the event.
		 */
		WHEEL_EVENT(6),
		/**
		 * A wheel event generated by a second<br>
		 * horizontal wheel that is present on some<br>
		 * mice. See WHEEL_EVENT.
		 */
		HORIZ_WHEEL_EVENT(7),
		/**
		 * .code gives the number of the mouse button<br>
		 * that was clicked.<br>
		 * .modifiers holds the state of the modifier<br>
		 * keys.<br>
		 * .part is a lisp symbol indicating which<br>
		 * part of the scroll bar got clicked.<br>
		 * .x gives the distance from the start of the<br>
		 * scroll bar of the click; .y gives the total<br>
		 * length of the scroll bar.<br>
		 * .frame_or_window gives the window<br>
		 * whose scroll bar was clicked in.<br>
		 * .timestamp gives a timestamp (in<br>
		 * milliseconds) for the click.
		 */
		SCROLL_BAR_CLICK_EVENT(8),
		/**
		 * Another X client wants a selection from us.<br>
		 * See `struct selection_input_event'.
		 */
		SELECTION_REQUEST_EVENT(9),
		/// Another X client cleared our selection.
		SELECTION_CLEAR_EVENT(10),
		/// A process filter has switched buffers.
		BUFFER_SWITCH_EVENT(11),
		/// An X client said "delete this window".
		DELETE_WINDOW_EVENT(12),
		/**
		 * An event generated by the menu bar.<br>
		 * The frame_or_window field's cdr holds the<br>
		 * Lisp-level event value.<br>
		 * (Only the toolkit version uses these.)
		 */
		MENU_BAR_EVENT(13),
		/// An X client iconified this window.
		ICONIFY_EVENT(14),
		/// An X client deiconified this window.
		DEICONIFY_EVENT(15),
		/**
		 * A button press in the menu bar<br>
		 * (toolkit version only).
		 */
		MENU_BAR_ACTIVATE_EVENT(16),
		/**
		 * A drag-n-drop event is generated when<br>
		 * files selected outside of Emacs are dropped<br>
		 * onto an Emacs window.<br>
		 * .modifiers holds the state of the<br>
		 * modifier keys.<br>
		 * .x and .y give the mouse position,<br>
		 * in characters, within the window.<br>
		 * .frame_or_window is the frame in<br>
		 * which the drop was made.<br>
		 * .arg is a platform-dependent<br>
		 * representation of the dropped items.<br>
		 * .timestamp gives a timestamp (in<br>
		 * milliseconds) for the click.
		 */
		DRAG_N_DROP_EVENT(17),
		/**
		 * A user signal.<br>
		 * code is a number identifying it,<br>
		 * index into lispy_user_signals.
		 */
		USER_SIGNAL_EVENT(18),
		/**
		 * Help events.  Member `frame_or_window' of the input_event is the<br>
		 * frame on which the event occurred, and member `arg' contains<br>
		 * the help to show.
		 */
		HELP_EVENT(19),
		/**
		 * An event from a tool-bar.  Member `arg' of the input event<br>
		 * contains the tool-bar item selected.  If `frame_or_window'<br>
		 * and `arg' are equal, this is a prefix event.
		 */
		TOOL_BAR_EVENT(20),
		/**
		 * Queued from XTread_socket on FocusIn events.  Translated into<br>
		 * `switch-frame' events in kbd_buffer_get_event, if necessary.
		 */
		FOCUS_IN_EVENT(21),
		/// Generated when mouse moves over window not currently selected.
		SELECT_WINDOW_EVENT(22),
		/**
		 * Queued from XTread_socket when session manager sends<br>
		 * save yourself before shutdown.
		 */
		SAVE_SESSION_EVENT(23),
		CONFIG_CHANGED_EVENT(24);
		event_kind(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<event_kind > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<event_kind > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * Only used on mouse buttons - always<br>
	 * turned into a click or a drag modifier<br>
	 * before lisp code sees the event.
	 */
	public static final int up_modifier = (int)1;
	/// Only used on mouse buttons.
	public static final int down_modifier = (int)2;
	/**
	 * This is never used in the event<br>
	 * queue; it's only used internally by<br>
	 * the window-system-independent code.
	 */
	public static final int drag_modifier = (int)4;
	/// See drag_modifier.
	public static final int click_modifier = (int)8;
	/// See drag_modifier.
	public static final int double_modifier = (int)16;
	/// See drag_modifier.
	public static final int triple_modifier = (int)32;
	/// Failed to infer type of Pair(CHAR_ALT, null)
	/// Failed to infer type of Pair(CHAR_SUPER, null)
	/// Failed to infer type of Pair(CHAR_HYPER, null)
	/// Failed to infer type of Pair(CHAR_SHIFT, null)
	/// Failed to infer type of Pair(CHAR_CTL, null)
	/// Failed to infer type of Pair(CHAR_META, null)
	/// <i>native declaration : termhooks.h:795</i>
	/// <i>native declaration : termhooks.h:795</i>
	public static abstract class fullscreen_hook_callback extends Callback<fullscreen_hook_callback > {
		public abstract void apply(Pointer<TermhooksLibrary.frame > f);
	};
	/**
	 * Original signature : <code>int set_file_times(const char*, int, int)</code><br>
	 * <i>native declaration : systime.h:303</i>
	 */
	public static native int set_file_times(Pointer<Byte > charPtr1, int int1, int int2);
	/**
	 * defined in keyboard.c<br>
	 * Original signature : <code>void set_waiting_for_input(int*)</code><br>
	 * <i>native declaration : systime.h:308</i>
	 */
	public static native void set_waiting_for_input(Pointer<Integer > intPtr1);
	/**
	 * Original signature : <code>terminal* get_terminal(Lisp_Object, int)</code><br>
	 * <i>native declaration : termhooks.h:786</i>
	 */
	public static native Pointer<terminal > get_terminal(TermhooksLibrary.Lisp_Object terminal, int int1);
	/**
	 * Original signature : <code>terminal* create_terminal()</code><br>
	 * <i>native declaration : termhooks.h:788</i>
	 */
	public static native Pointer<terminal > create_terminal();
	/**
	 * Original signature : <code>void delete_terminal(terminal*)</code><br>
	 * <i>native declaration : termhooks.h:790</i>
	 */
	public static native void delete_terminal(Pointer<terminal > terminalPtr1);
	/**
	 * Original signature : <code>char* encode_terminal_code(glyph*, int, coding_system*)</code><br>
	 * <i>native declaration : termhooks.h:794</i>
	 */
	public static native Pointer<Byte > encode_terminal_code(Pointer<TermhooksLibrary.glyph > glyphPtr1, int int1, Pointer<TermhooksLibrary.coding_system > coding_systemPtr1);
	/**
	 * If the value of the frame parameter changed, whis hook is called.<br>
	 * For example, if going from fullscreen to not fullscreen this hook<br>
	 * may do something OS dependent, like extended window manager hints on X11.<br>
	 * C type : fullscreen_hook_callback
	 */
	public Pointer<TermhooksLibrary.fullscreen_hook_callback > fullscreen_hook() {
		try {
			return (Pointer<TermhooksLibrary.fullscreen_hook_callback >)BridJ.getNativeLibrary("termhooks").getSymbolPointer("fullscreen_hook").as(DefaultParameterizedType.paramType(Pointer.class, TermhooksLibrary.fullscreen_hook_callback.class)).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/**
	 * If the value of the frame parameter changed, whis hook is called.<br>
	 * For example, if going from fullscreen to not fullscreen this hook<br>
	 * may do something OS dependent, like extended window manager hints on X11.<br>
	 * C type : fullscreen_hook_callback
	 */
	public TermhooksLibrary fullscreen_hook(Pointer<TermhooksLibrary.fullscreen_hook_callback > fullscreen_hook) {
		try {
			{
				BridJ.getNativeLibrary("termhooks").getSymbolPointer("fullscreen_hook").as(DefaultParameterizedType.paramType(Pointer.class, TermhooksLibrary.fullscreen_hook_callback.class)).set(fullscreen_hook);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/**
	 * Chain of all terminal devices currently in use.<br>
	 * C type : extern terminal*
	 */
	public Pointer<terminal > terminal_list() {
		try {
			return (Pointer<terminal >)BridJ.getNativeLibrary("termhooks").getSymbolPointer("terminal_list").as(DefaultParameterizedType.paramType(Pointer.class, terminal.class)).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/**
	 * Chain of all terminal devices currently in use.<br>
	 * C type : extern terminal*
	 */
	public TermhooksLibrary terminal_list(Pointer<terminal > terminal_list) {
		try {
			{
				BridJ.getNativeLibrary("termhooks").getSymbolPointer("terminal_list").as(DefaultParameterizedType.paramType(Pointer.class, terminal.class)).set(terminal_list);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/**
	 * The initial terminal device, created by initial_term_init.<br>
	 * C type : extern terminal*
	 */
	public Pointer<terminal > initial_terminal() {
		try {
			return (Pointer<terminal >)BridJ.getNativeLibrary("termhooks").getSymbolPointer("initial_terminal").as(DefaultParameterizedType.paramType(Pointer.class, terminal.class)).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/**
	 * The initial terminal device, created by initial_term_init.<br>
	 * C type : extern terminal*
	 */
	public TermhooksLibrary initial_terminal(Pointer<terminal > initial_terminal) {
		try {
			{
				BridJ.getNativeLibrary("termhooks").getSymbolPointer("initial_terminal").as(DefaultParameterizedType.paramType(Pointer.class, terminal.class)).set(initial_terminal);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/// Undefined type
	/// Undefined type
	public static interface w32_display_info {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface glyph {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface kboard {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface tty_display_info {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface ns_display_info {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface Lisp_Object {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface vectorlike_header {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface Time {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface frame {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface window {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface x_display_info {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface redisplay_interface {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface coding_system {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface EMACS_INT {
		
	};
}
