package emacs.termhooks;
import emacs.termhooks.TermhooksLibrary.Lisp_Object;
import emacs.termhooks.TermhooksLibrary.Time;
import emacs.termhooks.TermhooksLibrary.coding_system;
import emacs.termhooks.TermhooksLibrary.frame;
import emacs.termhooks.TermhooksLibrary.glyph;
import emacs.termhooks.TermhooksLibrary.kboard;
import emacs.termhooks.TermhooksLibrary.ns_display_info;
import emacs.termhooks.TermhooksLibrary.redisplay_interface;
import emacs.termhooks.TermhooksLibrary.scroll_bar_part;
import emacs.termhooks.TermhooksLibrary.tty_display_info;
import emacs.termhooks.TermhooksLibrary.w32_display_info;
import emacs.termhooks.TermhooksLibrary.window;
import emacs.termhooks.TermhooksLibrary.x_display_info;
import org.bridj.Callback;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
import org.bridj.ann.Union;
/**
 * Terminal-local parameters.<br>
 * <i>native declaration : termhooks.h:782</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("termhooks") 
public class terminal extends StructObject {
	public terminal() {
		super();
	}
	/**
	 * Chain of all terminal devices.<br>
	 * C type : terminal*
	 */
	@Field(4) 
	public Pointer<terminal > next_terminal() {
		return this.io.getPointerField(this, 4);
	}
	/**
	 * Chain of all terminal devices.<br>
	 * C type : terminal*
	 */
	@Field(4) 
	public terminal next_terminal(Pointer<terminal > next_terminal) {
		this.io.setPointerField(this, 4, next_terminal);
		return this;
	}
	/// Unique id for this terminal device.
	@Field(5) 
	public int id() {
		return this.io.getIntField(this, 5);
	}
	/// Unique id for this terminal device.
	@Field(5) 
	public terminal id(int id) {
		this.io.setIntField(this, 5, id);
		return this;
	}
	/// The number of frames that are on this terminal.
	@Field(6) 
	public int reference_count() {
		return this.io.getIntField(this, 6);
	}
	/// The number of frames that are on this terminal.
	@Field(6) 
	public terminal reference_count(int reference_count) {
		this.io.setIntField(this, 6, reference_count);
		return this;
	}
	/**
	 * The type of the terminal device.<br>
	 * C type : output_method
	 */
	@Field(7) 
	public IntValuedEnum<terminal.output_method > type() {
		return this.io.getEnumField(this, 7);
	}
	/**
	 * The type of the terminal device.<br>
	 * C type : output_method
	 */
	@Field(7) 
	public terminal type(IntValuedEnum<terminal.output_method > type) {
		this.io.setEnumField(this, 7, type);
		return this;
	}
	/**
	 * The name of the terminal device.  Do not use this to uniquely<br>
	 * identify a terminal; the same device may be opened multiple<br>
	 * times.<br>
	 * C type : char*
	 */
	@Field(8) 
	public Pointer<Byte > name() {
		return this.io.getPointerField(this, 8);
	}
	/**
	 * The name of the terminal device.  Do not use this to uniquely<br>
	 * identify a terminal; the same device may be opened multiple<br>
	 * times.<br>
	 * C type : char*
	 */
	@Field(8) 
	public terminal name(Pointer<Byte > name) {
		this.io.setPointerField(this, 8, name);
		return this;
	}
	/**
	 * The terminal's keyboard object.<br>
	 * C type : kboard*
	 */
	@Field(9) 
	public Pointer<kboard > kboard() {
		return this.io.getPointerField(this, 9);
	}
	/**
	 * The terminal's keyboard object.<br>
	 * C type : kboard*
	 */
	@Field(9) 
	public terminal kboard(Pointer<kboard > kboard) {
		this.io.setPointerField(this, 9, kboard);
		return this;
	}
	/**
	 * Device-type dependent data shared amongst all frames on this terminal.<br>
	 * C type : display_info
	 */
	@Field(10) 
	public terminal.display_info display_info() {
		return this.io.getNativeObjectField(this, 10);
	}
	/**
	 * Device-type dependent data shared amongst all frames on this terminal.<br>
	 * C type : display_info
	 */
	@Field(10) 
	public terminal display_info(terminal.display_info display_info) {
		this.io.setNativeObjectField(this, 10, display_info);
		return this;
	}
	/**
	 * Coding-system to be used for encoding terminal output.  This<br>
	 * structure contains information of a coding-system specified by<br>
	 * the function `set-terminal-coding-system'.  Also see<br>
	 * `safe_terminal_coding' in coding.h.<br>
	 * C type : coding_system*
	 */
	@Field(11) 
	public Pointer<coding_system > terminal_coding() {
		return this.io.getPointerField(this, 11);
	}
	/**
	 * Coding-system to be used for encoding terminal output.  This<br>
	 * structure contains information of a coding-system specified by<br>
	 * the function `set-terminal-coding-system'.  Also see<br>
	 * `safe_terminal_coding' in coding.h.<br>
	 * C type : coding_system*
	 */
	@Field(11) 
	public terminal terminal_coding(Pointer<coding_system > terminal_coding) {
		this.io.setPointerField(this, 11, terminal_coding);
		return this;
	}
	/**
	 * Coding-system of what is sent from terminal keyboard.  This<br>
	 * structure contains information of a coding-system specified by<br>
	 * the function `set-keyboard-coding-system'.<br>
	 * C type : coding_system*
	 */
	@Field(12) 
	public Pointer<coding_system > keyboard_coding() {
		return this.io.getPointerField(this, 12);
	}
	/**
	 * Coding-system of what is sent from terminal keyboard.  This<br>
	 * structure contains information of a coding-system specified by<br>
	 * the function `set-keyboard-coding-system'.<br>
	 * C type : coding_system*
	 */
	@Field(12) 
	public terminal keyboard_coding(Pointer<coding_system > keyboard_coding) {
		this.io.setPointerField(this, 12, keyboard_coding);
		return this;
	}
	/**
	 * Nonzero means spaces in the text must<br>
	 * actually be output; can't just skip over<br>
	 * some columns to leave them blank.
	 */
	@Field(13) 
	public int must_write_spaces() {
		return this.io.getIntField(this, 13);
	}
	/**
	 * Nonzero means spaces in the text must<br>
	 * actually be output; can't just skip over<br>
	 * some columns to leave them blank.
	 */
	@Field(13) 
	public terminal must_write_spaces(int must_write_spaces) {
		this.io.setIntField(this, 13, must_write_spaces);
		return this;
	}
	/// Nonzero means terminal has a `ce' string
	@Field(14) 
	public int fast_clear_end_of_line() {
		return this.io.getIntField(this, 14);
	}
	/// Nonzero means terminal has a `ce' string
	@Field(14) 
	public terminal fast_clear_end_of_line(int fast_clear_end_of_line) {
		this.io.setIntField(this, 14, fast_clear_end_of_line);
		return this;
	}
	/// Terminal can insert and delete lines
	@Field(15) 
	public int line_ins_del_ok() {
		return this.io.getIntField(this, 15);
	}
	/// Terminal can insert and delete lines
	@Field(15) 
	public terminal line_ins_del_ok(int line_ins_del_ok) {
		this.io.setIntField(this, 15, line_ins_del_ok);
		return this;
	}
	/// Terminal can insert and delete chars
	@Field(16) 
	public int char_ins_del_ok() {
		return this.io.getIntField(this, 16);
	}
	/// Terminal can insert and delete chars
	@Field(16) 
	public terminal char_ins_del_ok(int char_ins_del_ok) {
		this.io.setIntField(this, 16, char_ins_del_ok);
		return this;
	}
	/**
	 * Terminal supports setting the scroll<br>
	 * window
	 */
	@Field(17) 
	public int scroll_region_ok() {
		return this.io.getIntField(this, 17);
	}
	/**
	 * Terminal supports setting the scroll<br>
	 * window
	 */
	@Field(17) 
	public terminal scroll_region_ok(int scroll_region_ok) {
		this.io.setIntField(this, 17, scroll_region_ok);
		return this;
	}
	/**
	 * Cost of setting the scroll window,<br>
	 * measured in characters.
	 */
	@Field(18) 
	public int scroll_region_cost() {
		return this.io.getIntField(this, 18);
	}
	/**
	 * Cost of setting the scroll window,<br>
	 * measured in characters.
	 */
	@Field(18) 
	public terminal scroll_region_cost(int scroll_region_cost) {
		this.io.setIntField(this, 18, scroll_region_cost);
		return this;
	}
	/**
	 * Terminal remembers lines scrolled<br>
	 * off bottom
	 */
	@Field(19) 
	public int memory_below_frame() {
		return this.io.getIntField(this, 19);
	}
	/**
	 * Terminal remembers lines scrolled<br>
	 * off bottom
	 */
	@Field(19) 
	public terminal memory_below_frame(int memory_below_frame) {
		this.io.setIntField(this, 19, memory_below_frame);
		return this;
	}
	/**
	 * Window-based redisplay interface for this device (0 for tty<br>
	 * devices).<br>
	 * C type : redisplay_interface*
	 */
	@Field(20) 
	public Pointer<redisplay_interface > rif() {
		return this.io.getPointerField(this, 20);
	}
	/**
	 * Window-based redisplay interface for this device (0 for tty<br>
	 * devices).<br>
	 * C type : redisplay_interface*
	 */
	@Field(20) 
	public terminal rif(Pointer<redisplay_interface > rif) {
		this.io.setPointerField(this, 20, rif);
		return this;
	}
	/// C type : cursor_to_hook_callback
	@Field(21) 
	public Pointer<terminal.cursor_to_hook_callback > cursor_to_hook() {
		return this.io.getPointerField(this, 21);
	}
	/// C type : cursor_to_hook_callback
	@Field(21) 
	public terminal cursor_to_hook(Pointer<terminal.cursor_to_hook_callback > cursor_to_hook) {
		this.io.setPointerField(this, 21, cursor_to_hook);
		return this;
	}
	/// C type : raw_cursor_to_hook_callback
	@Field(22) 
	public Pointer<terminal.raw_cursor_to_hook_callback > raw_cursor_to_hook() {
		return this.io.getPointerField(this, 22);
	}
	/// C type : raw_cursor_to_hook_callback
	@Field(22) 
	public terminal raw_cursor_to_hook(Pointer<terminal.raw_cursor_to_hook_callback > raw_cursor_to_hook) {
		this.io.setPointerField(this, 22, raw_cursor_to_hook);
		return this;
	}
	/// C type : clear_to_end_hook_callback
	@Field(23) 
	public Pointer<terminal.clear_to_end_hook_callback > clear_to_end_hook() {
		return this.io.getPointerField(this, 23);
	}
	/// C type : clear_to_end_hook_callback
	@Field(23) 
	public terminal clear_to_end_hook(Pointer<terminal.clear_to_end_hook_callback > clear_to_end_hook) {
		this.io.setPointerField(this, 23, clear_to_end_hook);
		return this;
	}
	/// C type : clear_frame_hook_callback
	@Field(24) 
	public Pointer<terminal.clear_frame_hook_callback > clear_frame_hook() {
		return this.io.getPointerField(this, 24);
	}
	/// C type : clear_frame_hook_callback
	@Field(24) 
	public terminal clear_frame_hook(Pointer<terminal.clear_frame_hook_callback > clear_frame_hook) {
		this.io.setPointerField(this, 24, clear_frame_hook);
		return this;
	}
	/// C type : clear_end_of_line_hook_callback
	@Field(25) 
	public Pointer<terminal.clear_end_of_line_hook_callback > clear_end_of_line_hook() {
		return this.io.getPointerField(this, 25);
	}
	/// C type : clear_end_of_line_hook_callback
	@Field(25) 
	public terminal clear_end_of_line_hook(Pointer<terminal.clear_end_of_line_hook_callback > clear_end_of_line_hook) {
		this.io.setPointerField(this, 25, clear_end_of_line_hook);
		return this;
	}
	/// C type : ins_del_lines_hook_callback
	@Field(26) 
	public Pointer<terminal.ins_del_lines_hook_callback > ins_del_lines_hook() {
		return this.io.getPointerField(this, 26);
	}
	/// C type : ins_del_lines_hook_callback
	@Field(26) 
	public terminal ins_del_lines_hook(Pointer<terminal.ins_del_lines_hook_callback > ins_del_lines_hook) {
		this.io.setPointerField(this, 26, ins_del_lines_hook);
		return this;
	}
	/// C type : insert_glyphs_hook_callback
	@Field(27) 
	public Pointer<terminal.insert_glyphs_hook_callback > insert_glyphs_hook() {
		return this.io.getPointerField(this, 27);
	}
	/// C type : insert_glyphs_hook_callback
	@Field(27) 
	public terminal insert_glyphs_hook(Pointer<terminal.insert_glyphs_hook_callback > insert_glyphs_hook) {
		this.io.setPointerField(this, 27, insert_glyphs_hook);
		return this;
	}
	/// C type : write_glyphs_hook_callback
	@Field(28) 
	public Pointer<terminal.write_glyphs_hook_callback > write_glyphs_hook() {
		return this.io.getPointerField(this, 28);
	}
	/// C type : write_glyphs_hook_callback
	@Field(28) 
	public terminal write_glyphs_hook(Pointer<terminal.write_glyphs_hook_callback > write_glyphs_hook) {
		this.io.setPointerField(this, 28, write_glyphs_hook);
		return this;
	}
	/// C type : delete_glyphs_hook_callback
	@Field(29) 
	public Pointer<terminal.delete_glyphs_hook_callback > delete_glyphs_hook() {
		return this.io.getPointerField(this, 29);
	}
	/// C type : delete_glyphs_hook_callback
	@Field(29) 
	public terminal delete_glyphs_hook(Pointer<terminal.delete_glyphs_hook_callback > delete_glyphs_hook) {
		this.io.setPointerField(this, 29, delete_glyphs_hook);
		return this;
	}
	/// C type : ring_bell_hook_callback
	@Field(30) 
	public Pointer<terminal.ring_bell_hook_callback > ring_bell_hook() {
		return this.io.getPointerField(this, 30);
	}
	/// C type : ring_bell_hook_callback
	@Field(30) 
	public terminal ring_bell_hook(Pointer<terminal.ring_bell_hook_callback > ring_bell_hook) {
		this.io.setPointerField(this, 30, ring_bell_hook);
		return this;
	}
	/// C type : toggle_invisible_pointer_hook_callback
	@Field(31) 
	public Pointer<terminal.toggle_invisible_pointer_hook_callback > toggle_invisible_pointer_hook() {
		return this.io.getPointerField(this, 31);
	}
	/// C type : toggle_invisible_pointer_hook_callback
	@Field(31) 
	public terminal toggle_invisible_pointer_hook(Pointer<terminal.toggle_invisible_pointer_hook_callback > toggle_invisible_pointer_hook) {
		this.io.setPointerField(this, 31, toggle_invisible_pointer_hook);
		return this;
	}
	/// C type : reset_terminal_modes_hook_callback
	@Field(32) 
	public Pointer<terminal.reset_terminal_modes_hook_callback > reset_terminal_modes_hook() {
		return this.io.getPointerField(this, 32);
	}
	/// C type : reset_terminal_modes_hook_callback
	@Field(32) 
	public terminal reset_terminal_modes_hook(Pointer<terminal.reset_terminal_modes_hook_callback > reset_terminal_modes_hook) {
		this.io.setPointerField(this, 32, reset_terminal_modes_hook);
		return this;
	}
	/// C type : set_terminal_modes_hook_callback
	@Field(33) 
	public Pointer<terminal.set_terminal_modes_hook_callback > set_terminal_modes_hook() {
		return this.io.getPointerField(this, 33);
	}
	/// C type : set_terminal_modes_hook_callback
	@Field(33) 
	public terminal set_terminal_modes_hook(Pointer<terminal.set_terminal_modes_hook_callback > set_terminal_modes_hook) {
		this.io.setPointerField(this, 33, set_terminal_modes_hook);
		return this;
	}
	/// C type : update_begin_hook_callback
	@Field(34) 
	public Pointer<terminal.update_begin_hook_callback > update_begin_hook() {
		return this.io.getPointerField(this, 34);
	}
	/// C type : update_begin_hook_callback
	@Field(34) 
	public terminal update_begin_hook(Pointer<terminal.update_begin_hook_callback > update_begin_hook) {
		this.io.setPointerField(this, 34, update_begin_hook);
		return this;
	}
	/// C type : update_end_hook_callback
	@Field(35) 
	public Pointer<terminal.update_end_hook_callback > update_end_hook() {
		return this.io.getPointerField(this, 35);
	}
	/// C type : update_end_hook_callback
	@Field(35) 
	public terminal update_end_hook(Pointer<terminal.update_end_hook_callback > update_end_hook) {
		this.io.setPointerField(this, 35, update_end_hook);
		return this;
	}
	/// C type : set_terminal_window_hook_callback
	@Field(36) 
	public Pointer<terminal.set_terminal_window_hook_callback > set_terminal_window_hook() {
		return this.io.getPointerField(this, 36);
	}
	/// C type : set_terminal_window_hook_callback
	@Field(36) 
	public terminal set_terminal_window_hook(Pointer<terminal.set_terminal_window_hook_callback > set_terminal_window_hook) {
		this.io.setPointerField(this, 36, set_terminal_window_hook);
		return this;
	}
	/**
	 * Return the current position of the mouse.<br>
	 * Set *f to the frame the mouse is in, or zero if the mouse is in no<br>
	 * Emacs frame.  If it is set to zero, all the other arguments are<br>
	 * garbage.<br>
	 * If the motion started in a scroll bar, set *bar_window to the<br>
	 * scroll bar's window, *part to the part the mouse is currently over,<br>
	 * x to the position of the mouse along the scroll bar, and *y to the<br>
	 * overall length of the scroll bar.<br>
	 * Otherwise, set *bar_window to Qnil, and *x and *y to the column and<br>
	 * row of the character cell the mouse is over.<br>
	 * Set *time to the time the mouse was at the returned position.<br>
	 * This should clear mouse_moved until the next motion<br>
	 * event arrives.<br>
	 * C type : mouse_position_hook_callback
	 */
	@Field(37) 
	public Pointer<terminal.mouse_position_hook_callback > mouse_position_hook() {
		return this.io.getPointerField(this, 37);
	}
	/**
	 * Return the current position of the mouse.<br>
	 * Set *f to the frame the mouse is in, or zero if the mouse is in no<br>
	 * Emacs frame.  If it is set to zero, all the other arguments are<br>
	 * garbage.<br>
	 * If the motion started in a scroll bar, set *bar_window to the<br>
	 * scroll bar's window, *part to the part the mouse is currently over,<br>
	 * x to the position of the mouse along the scroll bar, and *y to the<br>
	 * overall length of the scroll bar.<br>
	 * Otherwise, set *bar_window to Qnil, and *x and *y to the column and<br>
	 * row of the character cell the mouse is over.<br>
	 * Set *time to the time the mouse was at the returned position.<br>
	 * This should clear mouse_moved until the next motion<br>
	 * event arrives.<br>
	 * C type : mouse_position_hook_callback
	 */
	@Field(37) 
	public terminal mouse_position_hook(Pointer<terminal.mouse_position_hook_callback > mouse_position_hook) {
		this.io.setPointerField(this, 37, mouse_position_hook);
		return this;
	}
	/**
	 * The window system handling code should set this if the mouse has<br>
	 * moved since the last call to the mouse_position_hook.  Calling that<br>
	 * hook should clear this.
	 */
	@Field(38) 
	public int mouse_moved() {
		return this.io.getIntField(this, 38);
	}
	/**
	 * The window system handling code should set this if the mouse has<br>
	 * moved since the last call to the mouse_position_hook.  Calling that<br>
	 * hook should clear this.
	 */
	@Field(38) 
	public terminal mouse_moved(int mouse_moved) {
		this.io.setIntField(this, 38, mouse_moved);
		return this;
	}
	/**
	 * When a frame's focus redirection is changed, this hook tells the<br>
	 * window system code to re-decide where to put the highlight.  Under<br>
	 * X, this means that Emacs lies about where the focus is.<br>
	 * C type : frame_rehighlight_hook_callback
	 */
	@Field(39) 
	public Pointer<terminal.frame_rehighlight_hook_callback > frame_rehighlight_hook() {
		return this.io.getPointerField(this, 39);
	}
	/**
	 * When a frame's focus redirection is changed, this hook tells the<br>
	 * window system code to re-decide where to put the highlight.  Under<br>
	 * X, this means that Emacs lies about where the focus is.<br>
	 * C type : frame_rehighlight_hook_callback
	 */
	@Field(39) 
	public terminal frame_rehighlight_hook(Pointer<terminal.frame_rehighlight_hook_callback > frame_rehighlight_hook) {
		this.io.setPointerField(this, 39, frame_rehighlight_hook);
		return this;
	}
	/**
	 * If we're displaying frames using a window system that can stack<br>
	 * frames on top of each other, this hook allows you to bring a frame<br>
	 * to the front, or bury it behind all the other windows.  If this<br>
	 * hook is zero, that means the terminal we're displaying on doesn't<br>
	 * support overlapping frames, so there's no need to raise or lower<br>
	 * anything.<br>
	 * If RAISE_FLAG is non-zero, F is brought to the front, before all other<br>
	 * windows.  If RAISE_FLAG is zero, F is sent to the back, behind all other<br>
	 * windows.<br>
	 * C type : frame_raise_lower_hook_callback
	 */
	@Field(40) 
	public Pointer<terminal.frame_raise_lower_hook_callback > frame_raise_lower_hook() {
		return this.io.getPointerField(this, 40);
	}
	/**
	 * If we're displaying frames using a window system that can stack<br>
	 * frames on top of each other, this hook allows you to bring a frame<br>
	 * to the front, or bury it behind all the other windows.  If this<br>
	 * hook is zero, that means the terminal we're displaying on doesn't<br>
	 * support overlapping frames, so there's no need to raise or lower<br>
	 * anything.<br>
	 * If RAISE_FLAG is non-zero, F is brought to the front, before all other<br>
	 * windows.  If RAISE_FLAG is zero, F is sent to the back, behind all other<br>
	 * windows.<br>
	 * C type : frame_raise_lower_hook_callback
	 */
	@Field(40) 
	public terminal frame_raise_lower_hook(Pointer<terminal.frame_raise_lower_hook_callback > frame_raise_lower_hook) {
		this.io.setPointerField(this, 40, frame_raise_lower_hook);
		return this;
	}
	/**
	 * If the value of the frame parameter changed, whis hook is called.<br>
	 * For example, if going from fullscreen to not fullscreen this hook<br>
	 * may do something OS dependent, like extended window manager hints on X11.<br>
	 * C type : fullscreen_hook_callback
	 */
	@Field(41) 
	public Pointer<emacs.termhooks.TermhooksLibrary.fullscreen_hook_callback > fullscreen_hook() {
		return this.io.getPointerField(this, 41);
	}
	/**
	 * If the value of the frame parameter changed, whis hook is called.<br>
	 * For example, if going from fullscreen to not fullscreen this hook<br>
	 * may do something OS dependent, like extended window manager hints on X11.<br>
	 * C type : fullscreen_hook_callback
	 */
	@Field(41) 
	public terminal fullscreen_hook(Pointer<emacs.termhooks.TermhooksLibrary.fullscreen_hook_callback > fullscreen_hook) {
		this.io.setPointerField(this, 41, fullscreen_hook);
		return this;
	}
	/**
	 * Set the vertical scroll bar for WINDOW to have its upper left corner<br>
	 * at (TOP, LEFT), and be LENGTH rows high.  Set its handle to<br>
	 * indicate that we are displaying PORTION characters out of a total<br>
	 * of WHOLE characters, starting at POSITION.  If WINDOW doesn't yet<br>
	 * have a scroll bar, create one for it.<br>
	 * C type : set_vertical_scroll_bar_hook_callback
	 */
	@Field(42) 
	public Pointer<terminal.set_vertical_scroll_bar_hook_callback > set_vertical_scroll_bar_hook() {
		return this.io.getPointerField(this, 42);
	}
	/**
	 * Set the vertical scroll bar for WINDOW to have its upper left corner<br>
	 * at (TOP, LEFT), and be LENGTH rows high.  Set its handle to<br>
	 * indicate that we are displaying PORTION characters out of a total<br>
	 * of WHOLE characters, starting at POSITION.  If WINDOW doesn't yet<br>
	 * have a scroll bar, create one for it.<br>
	 * C type : set_vertical_scroll_bar_hook_callback
	 */
	@Field(42) 
	public terminal set_vertical_scroll_bar_hook(Pointer<terminal.set_vertical_scroll_bar_hook_callback > set_vertical_scroll_bar_hook) {
		this.io.setPointerField(this, 42, set_vertical_scroll_bar_hook);
		return this;
	}
	/**
	 * Arrange for all scroll bars on FRAME to be removed at the next call<br>
	 * to `*judge_scroll_bars_hook'.  A scroll bar may be spared if<br>
	 * `*redeem_scroll_bar_hook' is applied to its window before the judgment.<br>
	 * This should be applied to each frame each time its window tree is<br>
	 * redisplayed, even if it is not displaying scroll bars at the moment;<br>
	 * if the HAS_SCROLL_BARS flag has just been turned off, only calling<br>
	 * this and the judge_scroll_bars_hook will get rid of them.<br>
	 * If non-zero, this hook should be safe to apply to any frame,<br>
	 * whether or not it can support scroll bars, and whether or not it is<br>
	 * currently displaying them.<br>
	 * C type : condemn_scroll_bars_hook_callback
	 */
	@Field(43) 
	public Pointer<terminal.condemn_scroll_bars_hook_callback > condemn_scroll_bars_hook() {
		return this.io.getPointerField(this, 43);
	}
	/**
	 * Arrange for all scroll bars on FRAME to be removed at the next call<br>
	 * to `*judge_scroll_bars_hook'.  A scroll bar may be spared if<br>
	 * `*redeem_scroll_bar_hook' is applied to its window before the judgment.<br>
	 * This should be applied to each frame each time its window tree is<br>
	 * redisplayed, even if it is not displaying scroll bars at the moment;<br>
	 * if the HAS_SCROLL_BARS flag has just been turned off, only calling<br>
	 * this and the judge_scroll_bars_hook will get rid of them.<br>
	 * If non-zero, this hook should be safe to apply to any frame,<br>
	 * whether or not it can support scroll bars, and whether or not it is<br>
	 * currently displaying them.<br>
	 * C type : condemn_scroll_bars_hook_callback
	 */
	@Field(43) 
	public terminal condemn_scroll_bars_hook(Pointer<terminal.condemn_scroll_bars_hook_callback > condemn_scroll_bars_hook) {
		this.io.setPointerField(this, 43, condemn_scroll_bars_hook);
		return this;
	}
	/**
	 * Unmark WINDOW's scroll bar for deletion in this judgment cycle.<br>
	 * Note that it's okay to redeem a scroll bar that is not condemned.<br>
	 * C type : redeem_scroll_bar_hook_callback
	 */
	@Field(44) 
	public Pointer<terminal.redeem_scroll_bar_hook_callback > redeem_scroll_bar_hook() {
		return this.io.getPointerField(this, 44);
	}
	/**
	 * Unmark WINDOW's scroll bar for deletion in this judgment cycle.<br>
	 * Note that it's okay to redeem a scroll bar that is not condemned.<br>
	 * C type : redeem_scroll_bar_hook_callback
	 */
	@Field(44) 
	public terminal redeem_scroll_bar_hook(Pointer<terminal.redeem_scroll_bar_hook_callback > redeem_scroll_bar_hook) {
		this.io.setPointerField(this, 44, redeem_scroll_bar_hook);
		return this;
	}
	/**
	 * Remove all scroll bars on FRAME that haven't been saved since the<br>
	 * last call to `*condemn_scroll_bars_hook'.<br>
	 * This should be applied to each frame after each time its window<br>
	 * tree is redisplayed, even if it is not displaying scroll bars at the<br>
	 * moment; if the HAS_SCROLL_BARS flag has just been turned off, only<br>
	 * calling this and condemn_scroll_bars_hook will get rid of them.<br>
	 * If non-zero, this hook should be safe to apply to any frame,<br>
	 * whether or not it can support scroll bars, and whether or not it is<br>
	 * currently displaying them.<br>
	 * C type : judge_scroll_bars_hook_callback
	 */
	@Field(45) 
	public Pointer<terminal.judge_scroll_bars_hook_callback > judge_scroll_bars_hook() {
		return this.io.getPointerField(this, 45);
	}
	/**
	 * Remove all scroll bars on FRAME that haven't been saved since the<br>
	 * last call to `*condemn_scroll_bars_hook'.<br>
	 * This should be applied to each frame after each time its window<br>
	 * tree is redisplayed, even if it is not displaying scroll bars at the<br>
	 * moment; if the HAS_SCROLL_BARS flag has just been turned off, only<br>
	 * calling this and condemn_scroll_bars_hook will get rid of them.<br>
	 * If non-zero, this hook should be safe to apply to any frame,<br>
	 * whether or not it can support scroll bars, and whether or not it is<br>
	 * currently displaying them.<br>
	 * C type : judge_scroll_bars_hook_callback
	 */
	@Field(45) 
	public terminal judge_scroll_bars_hook(Pointer<terminal.judge_scroll_bars_hook_callback > judge_scroll_bars_hook) {
		this.io.setPointerField(this, 45, judge_scroll_bars_hook);
		return this;
	}
	/**
	 * Called to read input events.<br>
	 * TERMINAL indicates which terminal device to read from.  Input<br>
	 * events should be read into BUF, the size of which is given in<br>
	 * SIZE.  EXPECTED is non-zero if the caller suspects that new input<br>
	 * is available.<br>
	 * A positive return value indicates that that many input events<br>
	 * where read into BUF.<br>
	 * Zero means no events were immediately available.<br>
	 * A value of -1 means a transient read error, while -2 indicates<br>
	 * that the device was closed (hangup), and it should be deleted.<br>
	 * XXX Please note that a non-zero value of EXPECTED only means that<br>
	 * there is available input on at least one of the currently opened<br>
	 * terminal devices -- but not necessarily on this device.<br>
	 * Therefore, in most cases EXPECTED should be simply ignored.<br>
	 * XXX This documentation needs to be updated.<br>
	 * C type : read_socket_hook_callback
	 */
	@Field(46) 
	public Pointer<terminal.read_socket_hook_callback > read_socket_hook() {
		return this.io.getPointerField(this, 46);
	}
	/**
	 * Called to read input events.<br>
	 * TERMINAL indicates which terminal device to read from.  Input<br>
	 * events should be read into BUF, the size of which is given in<br>
	 * SIZE.  EXPECTED is non-zero if the caller suspects that new input<br>
	 * is available.<br>
	 * A positive return value indicates that that many input events<br>
	 * where read into BUF.<br>
	 * Zero means no events were immediately available.<br>
	 * A value of -1 means a transient read error, while -2 indicates<br>
	 * that the device was closed (hangup), and it should be deleted.<br>
	 * XXX Please note that a non-zero value of EXPECTED only means that<br>
	 * there is available input on at least one of the currently opened<br>
	 * terminal devices -- but not necessarily on this device.<br>
	 * Therefore, in most cases EXPECTED should be simply ignored.<br>
	 * XXX This documentation needs to be updated.<br>
	 * C type : read_socket_hook_callback
	 */
	@Field(46) 
	public terminal read_socket_hook(Pointer<terminal.read_socket_hook_callback > read_socket_hook) {
		this.io.setPointerField(this, 46, read_socket_hook);
		return this;
	}
	/**
	 * Called when a frame's display becomes entirely up to date.<br>
	 * C type : frame_up_to_date_hook_callback
	 */
	@Field(47) 
	public Pointer<terminal.frame_up_to_date_hook_callback > frame_up_to_date_hook() {
		return this.io.getPointerField(this, 47);
	}
	/**
	 * Called when a frame's display becomes entirely up to date.<br>
	 * C type : frame_up_to_date_hook_callback
	 */
	@Field(47) 
	public terminal frame_up_to_date_hook(Pointer<terminal.frame_up_to_date_hook_callback > frame_up_to_date_hook) {
		this.io.setPointerField(this, 47, frame_up_to_date_hook);
		return this;
	}
	/**
	 * Called to delete the device-specific portions of a frame that is<br>
	 * on this terminal device.<br>
	 * C type : delete_frame_hook_callback
	 */
	@Field(48) 
	public Pointer<terminal.delete_frame_hook_callback > delete_frame_hook() {
		return this.io.getPointerField(this, 48);
	}
	/**
	 * Called to delete the device-specific portions of a frame that is<br>
	 * on this terminal device.<br>
	 * C type : delete_frame_hook_callback
	 */
	@Field(48) 
	public terminal delete_frame_hook(Pointer<terminal.delete_frame_hook_callback > delete_frame_hook) {
		this.io.setPointerField(this, 48, delete_frame_hook);
		return this;
	}
	/**
	 * Called after the last frame on this terminal is deleted, or when<br>
	 * the display device was closed (hangup).<br>
	 * If this is NULL, then the generic delete_terminal is called<br>
	 * instead.  Otherwise the hook must call delete_terminal itself.<br>
	 * The hook must check for and close any live frames that are still<br>
	 * on the terminal.  delete_frame ensures that there are no live<br>
	 * frames on the terminal when it calls this hook, so infinite<br>
	 * recursion is prevented.<br>
	 * C type : delete_terminal_hook_callback
	 */
	@Field(49) 
	public Pointer<terminal.delete_terminal_hook_callback > delete_terminal_hook() {
		return this.io.getPointerField(this, 49);
	}
	/**
	 * Called after the last frame on this terminal is deleted, or when<br>
	 * the display device was closed (hangup).<br>
	 * If this is NULL, then the generic delete_terminal is called<br>
	 * instead.  Otherwise the hook must call delete_terminal itself.<br>
	 * The hook must check for and close any live frames that are still<br>
	 * on the terminal.  delete_frame ensures that there are no live<br>
	 * frames on the terminal when it calls this hook, so infinite<br>
	 * recursion is prevented.<br>
	 * C type : delete_terminal_hook_callback
	 */
	@Field(49) 
	public terminal delete_terminal_hook(Pointer<terminal.delete_terminal_hook_callback > delete_terminal_hook) {
		this.io.setPointerField(this, 49, delete_terminal_hook);
		return this;
	}
	/// <i>native declaration : termhooks.h:751</i>
	/// <i>native declaration : termhooks.h:751</i>
	@Union 
	public static class display_info extends StructObject {
		public display_info() {
			super();
		}
		/**
		 * termchar.h<br>
		 * C type : tty_display_info*
		 */
		@Field(0) 
		public Pointer<tty_display_info > tty() {
			return this.io.getPointerField(this, 0);
		}
		/**
		 * termchar.h<br>
		 * C type : tty_display_info*
		 */
		@Field(0) 
		public display_info tty(Pointer<tty_display_info > tty) {
			this.io.setPointerField(this, 0, tty);
			return this;
		}
		/**
		 * xterm.h<br>
		 * C type : x_display_info*
		 */
		@Field(1) 
		public Pointer<x_display_info > x() {
			return this.io.getPointerField(this, 1);
		}
		/**
		 * xterm.h<br>
		 * C type : x_display_info*
		 */
		@Field(1) 
		public display_info x(Pointer<x_display_info > x) {
			this.io.setPointerField(this, 1, x);
			return this;
		}
		/**
		 * w32term.h<br>
		 * C type : w32_display_info*
		 */
		@Field(2) 
		public Pointer<w32_display_info > w32() {
			return this.io.getPointerField(this, 2);
		}
		/**
		 * w32term.h<br>
		 * C type : w32_display_info*
		 */
		@Field(2) 
		public display_info w32(Pointer<w32_display_info > w32) {
			this.io.setPointerField(this, 2, w32);
			return this;
		}
		/**
		 * nsterm.h<br>
		 * C type : ns_display_info*
		 */
		@Field(3) 
		public Pointer<ns_display_info > ns() {
			return this.io.getPointerField(this, 3);
		}
		/**
		 * nsterm.h<br>
		 * C type : ns_display_info*
		 */
		@Field(3) 
		public display_info ns(Pointer<ns_display_info > ns) {
			this.io.setPointerField(this, 3, ns);
			return this;
		}
	};
	/// <i>native declaration : termhooks.h:752</i>
	/// <i>native declaration : termhooks.h:752</i>
	public static abstract class cursor_to_hook_callback extends Callback<cursor_to_hook_callback > {
		public abstract void apply(Pointer<frame > f, int vpos, int hpos);
	};
	/// <i>native declaration : termhooks.h:753</i>
	/// <i>native declaration : termhooks.h:753</i>
	public static abstract class raw_cursor_to_hook_callback extends Callback<raw_cursor_to_hook_callback > {
		public abstract void apply(Pointer<frame > framePtr1, int int1, int int2);
	};
	/// <i>native declaration : termhooks.h:754</i>
	/// <i>native declaration : termhooks.h:754</i>
	public static abstract class clear_to_end_hook_callback extends Callback<clear_to_end_hook_callback > {
		public abstract void apply(Pointer<frame > framePtr1);
	};
	/// <i>native declaration : termhooks.h:755</i>
	/// <i>native declaration : termhooks.h:755</i>
	public static abstract class clear_frame_hook_callback extends Callback<clear_frame_hook_callback > {
		public abstract void apply(Pointer<frame > framePtr1);
	};
	/// <i>native declaration : termhooks.h:756</i>
	/// <i>native declaration : termhooks.h:756</i>
	public static abstract class clear_end_of_line_hook_callback extends Callback<clear_end_of_line_hook_callback > {
		public abstract void apply(Pointer<frame > framePtr1, int int1);
	};
	/// <i>native declaration : termhooks.h:757</i>
	/// <i>native declaration : termhooks.h:757</i>
	public static abstract class ins_del_lines_hook_callback extends Callback<ins_del_lines_hook_callback > {
		public abstract void apply(Pointer<frame > f, int int1, int int2);
	};
	/// <i>native declaration : termhooks.h:758</i>
	/// <i>native declaration : termhooks.h:758</i>
	public static abstract class insert_glyphs_hook_callback extends Callback<insert_glyphs_hook_callback > {
		public abstract void apply(Pointer<frame > f, Pointer<glyph > s, int n);
	};
	/// <i>native declaration : termhooks.h:759</i>
	/// <i>native declaration : termhooks.h:759</i>
	public static abstract class write_glyphs_hook_callback extends Callback<write_glyphs_hook_callback > {
		public abstract void apply(Pointer<frame > f, Pointer<glyph > s, int n);
	};
	/// <i>native declaration : termhooks.h:760</i>
	/// <i>native declaration : termhooks.h:760</i>
	public static abstract class delete_glyphs_hook_callback extends Callback<delete_glyphs_hook_callback > {
		public abstract void apply(Pointer<frame > framePtr1, int int1);
	};
	/// <i>native declaration : termhooks.h:761</i>
	/// <i>native declaration : termhooks.h:761</i>
	public static abstract class ring_bell_hook_callback extends Callback<ring_bell_hook_callback > {
		public abstract void apply(Pointer<frame > f);
	};
	/// <i>native declaration : termhooks.h:762</i>
	/// <i>native declaration : termhooks.h:762</i>
	public static abstract class toggle_invisible_pointer_hook_callback extends Callback<toggle_invisible_pointer_hook_callback > {
		public abstract void apply(Pointer<frame > f, int invisible);
	};
	/// <i>native declaration : termhooks.h:763</i>
	/// <i>native declaration : termhooks.h:763</i>
	public static abstract class reset_terminal_modes_hook_callback extends Callback<reset_terminal_modes_hook_callback > {
		public abstract void apply(Pointer<terminal > terminalPtr1);
	};
	/// <i>native declaration : termhooks.h:764</i>
	/// <i>native declaration : termhooks.h:764</i>
	public static abstract class set_terminal_modes_hook_callback extends Callback<set_terminal_modes_hook_callback > {
		public abstract void apply(Pointer<terminal > terminalPtr1);
	};
	/// <i>native declaration : termhooks.h:765</i>
	/// <i>native declaration : termhooks.h:765</i>
	public static abstract class update_begin_hook_callback extends Callback<update_begin_hook_callback > {
		public abstract void apply(Pointer<frame > framePtr1);
	};
	/// <i>native declaration : termhooks.h:766</i>
	/// <i>native declaration : termhooks.h:766</i>
	public static abstract class update_end_hook_callback extends Callback<update_end_hook_callback > {
		public abstract void apply(Pointer<frame > framePtr1);
	};
	/// <i>native declaration : termhooks.h:767</i>
	/// <i>native declaration : termhooks.h:767</i>
	public static abstract class set_terminal_window_hook_callback extends Callback<set_terminal_window_hook_callback > {
		public abstract void apply(Pointer<frame > framePtr1, int int1);
	};
	/// <i>native declaration : termhooks.h:770</i>
	/// <i>native declaration : termhooks.h:770</i>
	public static abstract class mouse_position_hook_callback extends Callback<mouse_position_hook_callback > {
		public abstract void apply(Pointer<Pointer<frame > > f, int int1, Pointer<Lisp_Object > bar_window, Pointer<IntValuedEnum<scroll_bar_part > > part, Pointer<Lisp_Object > x, Pointer<Lisp_Object > y, Pointer<Time > TimePtr1);
	};
	/// <i>native declaration : termhooks.h:771</i>
	/// <i>native declaration : termhooks.h:771</i>
	public static abstract class frame_rehighlight_hook_callback extends Callback<frame_rehighlight_hook_callback > {
		public abstract void apply(Pointer<frame > framePtr1);
	};
	/// <i>native declaration : termhooks.h:772</i>
	/// <i>native declaration : termhooks.h:772</i>
	public static abstract class frame_raise_lower_hook_callback extends Callback<frame_raise_lower_hook_callback > {
		public abstract void apply(Pointer<frame > f, int raise_flag);
	};
	/// <i>native declaration : termhooks.h:773</i>
	/// <i>native declaration : termhooks.h:773</i>
	public static abstract class fullscreen_hook_callback extends Callback<fullscreen_hook_callback > {
		public abstract void apply(Pointer<frame > f);
	};
	/// <i>native declaration : termhooks.h:774</i>
	/// <i>native declaration : termhooks.h:774</i>
	public static abstract class set_vertical_scroll_bar_hook_callback extends Callback<set_vertical_scroll_bar_hook_callback > {
		public abstract void apply(Pointer<window > window, int portion, int whole, int position);
	};
	/// <i>native declaration : termhooks.h:775</i>
	/// <i>native declaration : termhooks.h:775</i>
	public static abstract class condemn_scroll_bars_hook_callback extends Callback<condemn_scroll_bars_hook_callback > {
		public abstract void apply(Pointer<frame > frame);
	};
	/// <i>native declaration : termhooks.h:776</i>
	/// <i>native declaration : termhooks.h:776</i>
	public static abstract class redeem_scroll_bar_hook_callback extends Callback<redeem_scroll_bar_hook_callback > {
		public abstract void apply(Pointer<window > window);
	};
	/// <i>native declaration : termhooks.h:777</i>
	/// <i>native declaration : termhooks.h:777</i>
	public static abstract class judge_scroll_bars_hook_callback extends Callback<judge_scroll_bars_hook_callback > {
		public abstract void apply(Pointer<frame > FRAME);
	};
	/// <i>native declaration : termhooks.h:778</i>
	/// <i>native declaration : termhooks.h:778</i>
	public static abstract class read_socket_hook_callback extends Callback<read_socket_hook_callback > {
		public abstract int apply(Pointer<terminal > terminal, int expected, Pointer<input_event > hold_quit);
	};
	/// <i>native declaration : termhooks.h:779</i>
	/// <i>native declaration : termhooks.h:779</i>
	public static abstract class frame_up_to_date_hook_callback extends Callback<frame_up_to_date_hook_callback > {
		public abstract void apply(Pointer<frame > framePtr1);
	};
	/// <i>native declaration : termhooks.h:780</i>
	/// <i>native declaration : termhooks.h:780</i>
	public static abstract class delete_frame_hook_callback extends Callback<delete_frame_hook_callback > {
		public abstract void apply(Pointer<frame > framePtr1);
	};
	/// <i>native declaration : termhooks.h:781</i>
	/// <i>native declaration : termhooks.h:781</i>
	public static abstract class delete_terminal_hook_callback extends Callback<delete_terminal_hook_callback > {
		public abstract void apply(Pointer<terminal > terminalPtr1);
	};
}
