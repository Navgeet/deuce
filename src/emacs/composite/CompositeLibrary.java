package emacs.composite;
import java.util.Collections;
import java.util.Iterator;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
import org.bridj.util.DefaultParameterizedType;
/**
 * Wrapper for library <b>composite</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("composite") 
@Runtime(CRuntime.class) 
public class CompositeLibrary {
	static {
		BridJ.register();
	}
	/**
	 * Methods to display a sequence of components of a composition.<br>
	 * enum values<br>
	 * <i>native declaration : composite.h:16</i>
	 */
	public enum composition_method implements IntValuedEnum<composition_method > {
		/// Compose relatively without alternate characters.
		COMPOSITION_RELATIVE(0),
		/**
		 * Compose by specified composition rules.  This is not used in<br>
		 * Emacs 21 but we need it to decode files saved in the older<br>
		 * versions of Emacs.
		 */
		COMPOSITION_WITH_RULE(1),
		/// Compose relatively with alternate characters.
		COMPOSITION_WITH_ALTCHARS(2),
		/// Compose by specified composition rules with alternate characters.
		COMPOSITION_WITH_RULE_ALTCHARS(3),
		/// This is not a method.
		COMPOSITION_NO(4);
		composition_method(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<composition_method > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<composition_method > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * Vector size of Lispy glyph.<br>
	 * enum values<br>
	 * <i>native declaration : composite.h:93</i>
	 */
	public enum lglyph_indices implements IntValuedEnum<lglyph_indices > {
		LGLYPH_IX_FROM(0),
		LGLYPH_IX_TO(1),
		LGLYPH_IX_CHAR(2),
		LGLYPH_IX_CODE(3),
		LGLYPH_IX_WIDTH(4),
		LGLYPH_IX_LBEARING(5),
		LGLYPH_IX_RBEARING(6),
		LGLYPH_IX_ASCENT(7),
		LGLYPH_IX_DESCENT(8),
		LGLYPH_IX_ADJUSTMENT(9),
		/// Not an index.
		LGLYPH_SIZE(10);
		lglyph_indices(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<lglyph_indices > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<lglyph_indices > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// <i>native declaration : composite.h</i>
	public static final int CHECK_TAIL = (int)2;
	/// <i>native declaration : composite.h</i>
	public static final int CHECK_INSIDE = (int)4;
	/// <i>native declaration : composite.h</i>
	public static final int CHECK_HEAD = (int)1;
	/// <i>native declaration : composite.h</i>
	public static final int CHECK_ALL = (int)((1 | 2) | 4);
	/// <i>native declaration : composite.h</i>
	public static final int CHECK_BORDER = (int)(1 | 2);
	/// <i>native declaration : composite.h</i>
	public static final int MAX_COMPOSITION_COMPONENTS = (int)16;
	/**
	 * Original signature : <code>ptrdiff_t get_composition_id(Lisp_Object, Lisp_Object)</code><br>
	 * <i>native declaration : composite.h:66</i>
	 */
	@Ptr 
	public static native long get_composition_id(CompositeLibrary.Lisp_Object Lisp_Object1, CompositeLibrary.Lisp_Object Lisp_Object2);
	/**
	 * Original signature : <code>int find_composition(EMACS_INT*, EMACS_INT*, Lisp_Object*, Lisp_Object)</code><br>
	 * <i>native declaration : composite.h:68</i>
	 */
	public static native int find_composition(Pointer<CompositeLibrary.EMACS_INT > EMACS_INTPtr1, Pointer<CompositeLibrary.EMACS_INT > EMACS_INTPtr2, Pointer<CompositeLibrary.Lisp_Object > Lisp_ObjectPtr1, CompositeLibrary.Lisp_Object Lisp_Object1);
	/**
	 * Original signature : <code>void update_compositions(int)</code><br>
	 * <i>native declaration : composite.h:70</i>
	 */
	public static native void update_compositions(int int1);
	/**
	 * Original signature : <code>void make_composition_value_copy(Lisp_Object)</code><br>
	 * <i>native declaration : composite.h:72</i>
	 */
	public static native void make_composition_value_copy(CompositeLibrary.Lisp_Object Lisp_Object1);
	/**
	 * Original signature : <code>void compose_region(int, int, Lisp_Object, Lisp_Object, Lisp_Object)</code><br>
	 * <i>native declaration : composite.h:74</i>
	 */
	public static native void compose_region(int int1, int int2, CompositeLibrary.Lisp_Object Lisp_Object1, CompositeLibrary.Lisp_Object Lisp_Object2, CompositeLibrary.Lisp_Object Lisp_Object3);
	/**
	 * Original signature : <code>void syms_of_composite()</code><br>
	 * <i>native declaration : composite.h:76</i>
	 */
	public static native void syms_of_composite();
	/**
	 * Original signature : <code>void compose_text(Lisp_Object, Lisp_Object, Lisp_Object)</code><br>
	 * <i>native declaration : composite.h:78</i>
	 */
	public static native void compose_text(CompositeLibrary.Lisp_Object Lisp_Object1, CompositeLibrary.Lisp_Object Lisp_Object2, CompositeLibrary.Lisp_Object Lisp_Object3);
	/**
	 * Original signature : <code>Lisp_Object composition_gstring_put_cache(Lisp_Object)</code><br>
	 * <i>native declaration : composite.h:98</i>
	 */
	public static native CompositeLibrary.Lisp_Object composition_gstring_put_cache(CompositeLibrary.Lisp_Object Lisp_Object1);
	/**
	 * Original signature : <code>Lisp_Object composition_gstring_from_id(ptrdiff_t)</code><br>
	 * <i>native declaration : composite.h:100</i>
	 */
	public static native CompositeLibrary.Lisp_Object composition_gstring_from_id(@Ptr long ptrdiff_t1);
	/**
	 * Original signature : <code>int composition_gstring_p(Lisp_Object)</code><br>
	 * <i>native declaration : composite.h:102</i>
	 */
	public static native int composition_gstring_p(CompositeLibrary.Lisp_Object Lisp_Object1);
	/**
	 * Original signature : <code>int composition_gstring_width(Lisp_Object, font_metrics*)</code><br>
	 * <i>native declaration : composite.h:104</i>
	 */
	public static native int composition_gstring_width(CompositeLibrary.Lisp_Object Lisp_Object1, Pointer<CompositeLibrary.font_metrics > font_metricsPtr1);
	/**
	 * Original signature : <code>void composition_compute_stop_pos(composition_it*, Lisp_Object)</code><br>
	 * <i>native declaration : composite.h:106</i>
	 */
	public static native void composition_compute_stop_pos(Pointer<CompositeLibrary.composition_it > composition_itPtr1, CompositeLibrary.Lisp_Object Lisp_Object1);
	/**
	 * Original signature : <code>int composition_reseat_it(composition_it*, window*, face*, Lisp_Object)</code><br>
	 * <i>native declaration : composite.h:108</i>
	 */
	public static native int composition_reseat_it(Pointer<CompositeLibrary.composition_it > composition_itPtr1, Pointer<CompositeLibrary.window > windowPtr1, Pointer<CompositeLibrary.face > facePtr1, CompositeLibrary.Lisp_Object Lisp_Object1);
	/**
	 * Original signature : <code>int composition_update_it(composition_it*, Lisp_Object)</code><br>
	 * <i>native declaration : composite.h:110</i>
	 */
	public static native int composition_update_it(Pointer<CompositeLibrary.composition_it > composition_itPtr1, CompositeLibrary.Lisp_Object Lisp_Object1);
	/**
	 * Original signature : <code>EMACS_INT composition_adjust_point(EMACS_INT, EMACS_INT)</code><br>
	 * <i>native declaration : composite.h:112</i>
	 */
	public static native CompositeLibrary.EMACS_INT composition_adjust_point(CompositeLibrary.EMACS_INT EMACS_INT1, CompositeLibrary.EMACS_INT EMACS_INT2);
	/**
	 * Table of pointers to the structure `composition' indexed by<br>
	 * COMPOSITION-ID.<br>
	 * C type : extern composition**
	 */
	public Pointer<Pointer<composition > > composition_table() {
		try {
			return (Pointer<Pointer<composition > >)BridJ.getNativeLibrary("composite").getSymbolPointer("composition_table").as(DefaultParameterizedType.paramType(Pointer.class, DefaultParameterizedType.paramType(Pointer.class, composition.class))).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/**
	 * Table of pointers to the structure `composition' indexed by<br>
	 * COMPOSITION-ID.<br>
	 * C type : extern composition**
	 */
	public CompositeLibrary composition_table(Pointer<Pointer<composition > > composition_table) {
		try {
			{
				BridJ.getNativeLibrary("composite").getSymbolPointer("composition_table").as(DefaultParameterizedType.paramType(Pointer.class, DefaultParameterizedType.paramType(Pointer.class, composition.class))).set(composition_table);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/// Number of the currently registered compositions.
	@Ptr 
	public long n_compositions() {
		try {
			return (long)BridJ.getNativeLibrary("composite").getSymbolPointer("n_compositions").as(long.class).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/// Number of the currently registered compositions.
	@Ptr 
	public CompositeLibrary n_compositions(long n_compositions) {
		try {
			{
				BridJ.getNativeLibrary("composite").getSymbolPointer("n_compositions").as(long.class).set(n_compositions);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/// Undefined type
	/// Undefined type
	public static interface face {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface window {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface composition_it {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface font_metrics {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface Lisp_Object {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface EMACS_INT {
		
	};
}
