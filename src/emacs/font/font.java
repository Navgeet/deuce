package emacs.font;
import emacs.font.FontLibrary.Lisp_Object;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Array;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
/**
 * <i>native declaration : font.h:321</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("font") 
public class font extends StructObject {
	public font() {
		super();
	}
	/// C type : Lisp_Object[FONT_OBJECT_MAX]
	@Array({(int)emacs.font.FontLibrary.font_property_index.FONT_OBJECT_MAX.value()}) 
	@Field(1) 
	public Pointer<Lisp_Object > props() {
		return this.io.getPointerField(this, 1);
	}
	/**
	 * Maximum bound width over all existing characters of the font.  On<br>
	 * X window, this is same as (font->max_bounds.width).
	 */
	@Field(2) 
	public int max_width() {
		return this.io.getIntField(this, 2);
	}
	/**
	 * Maximum bound width over all existing characters of the font.  On<br>
	 * X window, this is same as (font->max_bounds.width).
	 */
	@Field(2) 
	public font max_width(int max_width) {
		this.io.setIntField(this, 2, max_width);
		return this;
	}
	/// By which pixel size the font is opened.
	@Field(3) 
	public int pixel_size() {
		return this.io.getIntField(this, 3);
	}
	/// By which pixel size the font is opened.
	@Field(3) 
	public font pixel_size(int pixel_size) {
		this.io.setIntField(this, 3, pixel_size);
		return this;
	}
	/**
	 * Height of the font.  On X window, this is the same as<br>
	 * (font->ascent + font->descent).
	 */
	@Field(4) 
	public int height() {
		return this.io.getIntField(this, 4);
	}
	/**
	 * Height of the font.  On X window, this is the same as<br>
	 * (font->ascent + font->descent).
	 */
	@Field(4) 
	public font height(int height) {
		this.io.setIntField(this, 4, height);
		return this;
	}
	/**
	 * Width of the space glyph of the font.  If the font doesn't have a<br>
	 * SPACE glyph, the value is 0.
	 */
	@Field(5) 
	public int space_width() {
		return this.io.getIntField(this, 5);
	}
	/**
	 * Width of the space glyph of the font.  If the font doesn't have a<br>
	 * SPACE glyph, the value is 0.
	 */
	@Field(5) 
	public font space_width(int space_width) {
		this.io.setIntField(this, 5, space_width);
		return this;
	}
	/**
	 * Average width of glyphs in the font.  If the font itself doesn't<br>
	 * have that information but has glyphs of ASCII characters, the<br>
	 * value is the average with of those glyphs.  Otherwise, the value<br>
	 * is 0.
	 */
	@Field(6) 
	public int average_width() {
		return this.io.getIntField(this, 6);
	}
	/**
	 * Average width of glyphs in the font.  If the font itself doesn't<br>
	 * have that information but has glyphs of ASCII characters, the<br>
	 * value is the average with of those glyphs.  Otherwise, the value<br>
	 * is 0.
	 */
	@Field(6) 
	public font average_width(int average_width) {
		this.io.setIntField(this, 6, average_width);
		return this;
	}
	/// Minimum glyph width (in pixels).
	@Field(7) 
	public int min_width() {
		return this.io.getIntField(this, 7);
	}
	/// Minimum glyph width (in pixels).
	@Field(7) 
	public font min_width(int min_width) {
		this.io.setIntField(this, 7, min_width);
		return this;
	}
	/// Ascent and descent of the font (in pixels).
	@Field(8) 
	public int ascent() {
		return this.io.getIntField(this, 8);
	}
	/// Ascent and descent of the font (in pixels).
	@Field(8) 
	public font ascent(int ascent) {
		this.io.setIntField(this, 8, ascent);
		return this;
	}
	/// Ascent and descent of the font (in pixels).
	@Field(9) 
	public int descent() {
		return this.io.getIntField(this, 9);
	}
	/// Ascent and descent of the font (in pixels).
	@Field(9) 
	public font descent(int descent) {
		this.io.setIntField(this, 9, descent);
		return this;
	}
	/**
	 * Vertical pixel width of the underline.  If is zero if that<br>
	 * information is not in the font.
	 */
	@Field(10) 
	public int underline_thickness() {
		return this.io.getIntField(this, 10);
	}
	/**
	 * Vertical pixel width of the underline.  If is zero if that<br>
	 * information is not in the font.
	 */
	@Field(10) 
	public font underline_thickness(int underline_thickness) {
		this.io.setIntField(this, 10, underline_thickness);
		return this;
	}
	/**
	 * Vertical pixel position (relative to the baseline) of the<br>
	 * underline.  If it is positive, it is below the baseline.  It is<br>
	 * negative if that information is not in the font.
	 */
	@Field(11) 
	public int underline_position() {
		return this.io.getIntField(this, 11);
	}
	/**
	 * Vertical pixel position (relative to the baseline) of the<br>
	 * underline.  If it is positive, it is below the baseline.  It is<br>
	 * negative if that information is not in the font.
	 */
	@Field(11) 
	public font underline_position(int underline_position) {
		this.io.setIntField(this, 11, underline_position);
		return this;
	}
	/**
	 * 1 if `vertical-centering-font-regexp' matches this font name.<br>
	 * In this case, we render characters at vertical center positions<br>
	 * of lines.
	 */
	@Field(12) 
	public int vertical_centering() {
		return this.io.getIntField(this, 12);
	}
	/**
	 * 1 if `vertical-centering-font-regexp' matches this font name.<br>
	 * In this case, we render characters at vertical center positions<br>
	 * of lines.
	 */
	@Field(12) 
	public font vertical_centering(int vertical_centering) {
		this.io.setIntField(this, 12, vertical_centering);
		return this;
	}
	/**
	 * Encoding type of the font.  The value is one of<br>
	 * 0, 1, 2, or 3:<br>
	 * 0: code points 0x20..0x7F or 0x2020..0x7F7F are used<br>
	 * 1: code points 0xA0..0xFF or 0xA0A0..0xFFFF are used<br>
	 * 2: code points 0x20A0..0x7FFF are used<br>
	 * 3: code points 0xA020..0xFF7F are used<br>
	 * If the member `font_encoder' is not NULL, this member is ignored.
	 */
	@Field(13) 
	public byte encoding_type() {
		return this.io.getByteField(this, 13);
	}
	/**
	 * Encoding type of the font.  The value is one of<br>
	 * 0, 1, 2, or 3:<br>
	 * 0: code points 0x20..0x7F or 0x2020..0x7F7F are used<br>
	 * 1: code points 0xA0..0xFF or 0xA0A0..0xFFFF are used<br>
	 * 2: code points 0x20A0..0x7FFF are used<br>
	 * 3: code points 0xA020..0xFF7F are used<br>
	 * If the member `font_encoder' is not NULL, this member is ignored.
	 */
	@Field(13) 
	public font encoding_type(byte encoding_type) {
		this.io.setByteField(this, 13, encoding_type);
		return this;
	}
	/**
	 * The baseline position of a font is normally `ascent' value of the<br>
	 * font.  However, there exist many fonts which don't set `ascent' to<br>
	 * an appropriate value to be used as baseline position.  This is<br>
	 * typical in such ASCII fonts which are designed to be used with<br>
	 * Chinese, Japanese, Korean characters.  When we use mixture of<br>
	 * such fonts and normal fonts (having correct `ascent' value), a<br>
	 * display line gets very ugly.  Since we have no way to fix it<br>
	 * automatically, it is user's responsibility to supply well designed<br>
	 * fonts or correct `ascent' value of fonts.  But, the latter<br>
	 * requires heavy work (modifying all bitmap data in BDF files).<br>
	 * So, Emacs accepts a private font property<br>
	 * `_MULE_BASELINE_OFFSET'.  If a font has this property, we<br>
	 * calculate the baseline position by subtracting the value from<br>
	 * `ascent'.  In other words, the value indicates how many pixels<br>
	 * higher than normal ASCII text we should draw a character of the<br>
	 * font for better appearance.<br>
	 * We also have to consider the fact that the concept of `baseline'<br>
	 * differs among scripts to which each character belongs.  For<br>
	 * instance, baseline should be at the bottom-most position of all<br>
	 * glyphs for Chinese, Japanese, and Korean.  But, many of existing<br>
	 * fonts for those characters don't have correct `ascent' values<br>
	 * because they are designed to be used with ASCII fonts.  To<br>
	 * display characters of different language on the same line, the<br>
	 * best way will be to arrange them in the middle of the line.  So,<br>
	 * in such a case, again, we utilize the font property<br>
	 * `_MULE_BASELINE_OFFSET'.  If the value is larger than `ascent' we<br>
	 * calculate baseline so that a character is arranged in the middle<br>
	 * of a line.
	 */
	@Field(14) 
	public int baseline_offset() {
		return this.io.getIntField(this, 14);
	}
	/**
	 * The baseline position of a font is normally `ascent' value of the<br>
	 * font.  However, there exist many fonts which don't set `ascent' to<br>
	 * an appropriate value to be used as baseline position.  This is<br>
	 * typical in such ASCII fonts which are designed to be used with<br>
	 * Chinese, Japanese, Korean characters.  When we use mixture of<br>
	 * such fonts and normal fonts (having correct `ascent' value), a<br>
	 * display line gets very ugly.  Since we have no way to fix it<br>
	 * automatically, it is user's responsibility to supply well designed<br>
	 * fonts or correct `ascent' value of fonts.  But, the latter<br>
	 * requires heavy work (modifying all bitmap data in BDF files).<br>
	 * So, Emacs accepts a private font property<br>
	 * `_MULE_BASELINE_OFFSET'.  If a font has this property, we<br>
	 * calculate the baseline position by subtracting the value from<br>
	 * `ascent'.  In other words, the value indicates how many pixels<br>
	 * higher than normal ASCII text we should draw a character of the<br>
	 * font for better appearance.<br>
	 * We also have to consider the fact that the concept of `baseline'<br>
	 * differs among scripts to which each character belongs.  For<br>
	 * instance, baseline should be at the bottom-most position of all<br>
	 * glyphs for Chinese, Japanese, and Korean.  But, many of existing<br>
	 * fonts for those characters don't have correct `ascent' values<br>
	 * because they are designed to be used with ASCII fonts.  To<br>
	 * display characters of different language on the same line, the<br>
	 * best way will be to arrange them in the middle of the line.  So,<br>
	 * in such a case, again, we utilize the font property<br>
	 * `_MULE_BASELINE_OFFSET'.  If the value is larger than `ascent' we<br>
	 * calculate baseline so that a character is arranged in the middle<br>
	 * of a line.
	 */
	@Field(14) 
	public font baseline_offset(int baseline_offset) {
		this.io.setIntField(this, 14, baseline_offset);
		return this;
	}
	/**
	 * Non-zero means a character should be composed at a position<br>
	 * relative to the height (or depth) of previous glyphs in the<br>
	 * following cases:<br>
	 * (1) The bottom of the character is higher than this value.  In<br>
	 * this case, the character is drawn above the previous glyphs.<br>
	 * (2) The top of the character is lower than 0 (i.e. baseline<br>
	 * height).  In this case, the character is drawn below the<br>
	 * previous glyphs.<br>
	 * This value is taken from a private font property<br>
	 * `_MULE_RELATIVE_COMPOSE' which is introduced by Emacs.
	 */
	@Field(15) 
	public int relative_compose() {
		return this.io.getIntField(this, 15);
	}
	/**
	 * Non-zero means a character should be composed at a position<br>
	 * relative to the height (or depth) of previous glyphs in the<br>
	 * following cases:<br>
	 * (1) The bottom of the character is higher than this value.  In<br>
	 * this case, the character is drawn above the previous glyphs.<br>
	 * (2) The top of the character is lower than 0 (i.e. baseline<br>
	 * height).  In this case, the character is drawn below the<br>
	 * previous glyphs.<br>
	 * This value is taken from a private font property<br>
	 * `_MULE_RELATIVE_COMPOSE' which is introduced by Emacs.
	 */
	@Field(15) 
	public font relative_compose(int relative_compose) {
		this.io.setIntField(this, 15, relative_compose);
		return this;
	}
	/**
	 * Non-zero means an ascent value to be used for a character<br>
	 * registered in char-table `use-default-ascent'.
	 */
	@Field(16) 
	public int default_ascent() {
		return this.io.getIntField(this, 16);
	}
	/**
	 * Non-zero means an ascent value to be used for a character<br>
	 * registered in char-table `use-default-ascent'.
	 */
	@Field(16) 
	public font default_ascent(int default_ascent) {
		this.io.setIntField(this, 16, default_ascent);
		return this;
	}
	/**
	 * CCL program to calculate code points of the font.<br>
	 * C type : ccl_program*
	 */
	@Field(17) 
	public Pointer<ccl_program > font_encoder() {
		return this.io.getPointerField(this, 17);
	}
	/**
	 * CCL program to calculate code points of the font.<br>
	 * C type : ccl_program*
	 */
	@Field(17) 
	public font font_encoder(Pointer<ccl_program > font_encoder) {
		this.io.setPointerField(this, 17, font_encoder);
		return this;
	}
	/**
	 * Font-driver for the font.<br>
	 * C type : font_driver*
	 */
	@Field(18) 
	public Pointer<font_driver > driver() {
		return this.io.getPointerField(this, 18);
	}
	/**
	 * Font-driver for the font.<br>
	 * C type : font_driver*
	 */
	@Field(18) 
	public font driver(Pointer<font_driver > driver) {
		this.io.setPointerField(this, 18, driver);
		return this;
	}
	/**
	 * Charset to encode a character code into a glyph code of the font.<br>
	 * -1 means that the font doesn't require this information to encode<br>
	 * a character.
	 */
	@Field(19) 
	public int encoding_charset() {
		return this.io.getIntField(this, 19);
	}
	/**
	 * Charset to encode a character code into a glyph code of the font.<br>
	 * -1 means that the font doesn't require this information to encode<br>
	 * a character.
	 */
	@Field(19) 
	public font encoding_charset(int encoding_charset) {
		this.io.setIntField(this, 19, encoding_charset);
		return this;
	}
	/**
	 * Charset to check if a character code is supported by the font.<br>
	 * -1 means that the contents of the font must be looked up to<br>
	 * determine it.
	 */
	@Field(20) 
	public int repertory_charset() {
		return this.io.getIntField(this, 20);
	}
	/**
	 * Charset to check if a character code is supported by the font.<br>
	 * -1 means that the contents of the font must be looked up to<br>
	 * determine it.
	 */
	@Field(20) 
	public font repertory_charset(int repertory_charset) {
		this.io.setIntField(this, 20, repertory_charset);
		return this;
	}
}
