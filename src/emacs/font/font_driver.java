package emacs.font;
import emacs.font.FontLibrary.FRAME_PTR;
import emacs.font.FontLibrary.Lisp_Object;
import emacs.font.FontLibrary.face;
import emacs.font.FontLibrary.frame;
import emacs.font.FontLibrary.glyph_string;
import org.bridj.Callback;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
/**
 * <i>native declaration : font.h:574</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("font") 
public class font_driver extends StructObject {
	public font_driver() {
		super();
	}
	/**
	 * 1 iff the font's foundry, family, and adstyle names are case<br>
	 * sensitive.
	 */
	@Field(1) 
	public int case_sensitive() {
		return this.io.getIntField(this, 1);
	}
	/**
	 * 1 iff the font's foundry, family, and adstyle names are case<br>
	 * sensitive.
	 */
	@Field(1) 
	public font_driver case_sensitive(int case_sensitive) {
		this.io.setIntField(this, 1, case_sensitive);
		return this;
	}
	/**
	 * Return a cache of font-entities on frame F.  The cache must be a<br>
	 * cons whose cdr part is the actual cache area.<br>
	 * C type : get_cache_callback
	 */
	@Field(2) 
	public Pointer<font_driver.get_cache_callback > get_cache() {
		return this.io.getPointerField(this, 2);
	}
	/**
	 * Return a cache of font-entities on frame F.  The cache must be a<br>
	 * cons whose cdr part is the actual cache area.<br>
	 * C type : get_cache_callback
	 */
	@Field(2) 
	public font_driver get_cache(Pointer<font_driver.get_cache_callback > get_cache) {
		this.io.setPointerField(this, 2, get_cache);
		return this;
	}
	/**
	 * List fonts exactly matching with FONT_SPEC on FRAME.  The value<br>
	 * is a list of font-entities.  The font properties to be considered<br>
	 * are: :foundry, :family, :adstyle, :registry, :script, :lang, and<br>
	 * :otf.  See the function `font-spec' for their meanings.  Note<br>
	 * that the last three properties are stored in FONT_EXTRA_INDEX<br>
	 * slot of FONT_SPEC.<br>
	 * The returned value is a list of font-entities.  Each font-entity<br>
	 * has :type property whose value is the same as the above `type'.<br>
	 * It also has these properties if they are available from the<br>
	 * corresponding font; :foundry, :family, :adstyle, :registry,<br>
	 * :weight, :slant, :width, :size, :dpi, :spacing, :avgwidth.  If<br>
	 * the font is scalable, :size and :avgwidth must be 0.<br>
	 * The `open' method of the same font-backend is called with one of<br>
	 * the returned font-entities.  If the backend needs additional<br>
	 * information to be used in `open' method, this method can add any<br>
	 * Lispy value by the property :font-entity to the entities.<br>
	 * This and the following `match' are the only APIs that allocate<br>
	 * font-entities.<br>
	 * C type : list_callback
	 */
	@Field(3) 
	public Pointer<font_driver.list_callback > list() {
		return this.io.getPointerField(this, 3);
	}
	/**
	 * List fonts exactly matching with FONT_SPEC on FRAME.  The value<br>
	 * is a list of font-entities.  The font properties to be considered<br>
	 * are: :foundry, :family, :adstyle, :registry, :script, :lang, and<br>
	 * :otf.  See the function `font-spec' for their meanings.  Note<br>
	 * that the last three properties are stored in FONT_EXTRA_INDEX<br>
	 * slot of FONT_SPEC.<br>
	 * The returned value is a list of font-entities.  Each font-entity<br>
	 * has :type property whose value is the same as the above `type'.<br>
	 * It also has these properties if they are available from the<br>
	 * corresponding font; :foundry, :family, :adstyle, :registry,<br>
	 * :weight, :slant, :width, :size, :dpi, :spacing, :avgwidth.  If<br>
	 * the font is scalable, :size and :avgwidth must be 0.<br>
	 * The `open' method of the same font-backend is called with one of<br>
	 * the returned font-entities.  If the backend needs additional<br>
	 * information to be used in `open' method, this method can add any<br>
	 * Lispy value by the property :font-entity to the entities.<br>
	 * This and the following `match' are the only APIs that allocate<br>
	 * font-entities.<br>
	 * C type : list_callback
	 */
	@Field(3) 
	public font_driver list(Pointer<font_driver.list_callback > list) {
		this.io.setPointerField(this, 3, list);
		return this;
	}
	/**
	 * Return a font-entity most closely matching with FONT_SPEC on<br>
	 * FRAME.  Which font property to consider, and how to calculate the<br>
	 * closeness is determined by the font backend, thus<br>
	 * `face-font-selection-order' is ignored here.<br>
	 * The properties that the font-entity has is the same as `list'<br>
	 * method.<br>
	 * C type : match_callback
	 */
	@Field(4) 
	public Pointer<font_driver.match_callback > match() {
		return this.io.getPointerField(this, 4);
	}
	/**
	 * Return a font-entity most closely matching with FONT_SPEC on<br>
	 * FRAME.  Which font property to consider, and how to calculate the<br>
	 * closeness is determined by the font backend, thus<br>
	 * `face-font-selection-order' is ignored here.<br>
	 * The properties that the font-entity has is the same as `list'<br>
	 * method.<br>
	 * C type : match_callback
	 */
	@Field(4) 
	public font_driver match(Pointer<font_driver.match_callback > match) {
		this.io.setPointerField(this, 4, match);
		return this;
	}
	/**
	 * Optional.<br>
	 * List available families.  The value is a list of family names<br>
	 * (symbols).<br>
	 * C type : list_family_callback
	 */
	@Field(5) 
	public Pointer<font_driver.list_family_callback > list_family() {
		return this.io.getPointerField(this, 5);
	}
	/**
	 * Optional.<br>
	 * List available families.  The value is a list of family names<br>
	 * (symbols).<br>
	 * C type : list_family_callback
	 */
	@Field(5) 
	public font_driver list_family(Pointer<font_driver.list_family_callback > list_family) {
		this.io.setPointerField(this, 5, list_family);
		return this;
	}
	/**
	 * Optional (if FONT_EXTRA_INDEX is not Lisp_Save_Value).<br>
	 * Free FONT_EXTRA_INDEX field of FONT_ENTITY.<br>
	 * C type : free_entity_callback
	 */
	@Field(6) 
	public Pointer<font_driver.free_entity_callback > free_entity() {
		return this.io.getPointerField(this, 6);
	}
	/**
	 * Optional (if FONT_EXTRA_INDEX is not Lisp_Save_Value).<br>
	 * Free FONT_EXTRA_INDEX field of FONT_ENTITY.<br>
	 * C type : free_entity_callback
	 */
	@Field(6) 
	public font_driver free_entity(Pointer<font_driver.free_entity_callback > free_entity) {
		this.io.setPointerField(this, 6, free_entity);
		return this;
	}
	/**
	 * Open a font specified by FONT_ENTITY on frame F.  If the font is<br>
	 * scalable, open it with PIXEL_SIZE.<br>
	 * C type : open_callback
	 */
	@Field(7) 
	public Pointer<font_driver.open_callback > open() {
		return this.io.getPointerField(this, 7);
	}
	/**
	 * Open a font specified by FONT_ENTITY on frame F.  If the font is<br>
	 * scalable, open it with PIXEL_SIZE.<br>
	 * C type : open_callback
	 */
	@Field(7) 
	public font_driver open(Pointer<font_driver.open_callback > open) {
		this.io.setPointerField(this, 7, open);
		return this;
	}
	/**
	 * Close FONT on frame F.<br>
	 * C type : close_callback
	 */
	@Field(8) 
	public Pointer<font_driver.close_callback > close() {
		return this.io.getPointerField(this, 8);
	}
	/**
	 * Close FONT on frame F.<br>
	 * C type : close_callback
	 */
	@Field(8) 
	public font_driver close(Pointer<font_driver.close_callback > close) {
		this.io.setPointerField(this, 8, close);
		return this;
	}
	/**
	 * Optional (if FACE->extra is not used).<br>
	 * Prepare FACE for displaying characters by FONT on frame F by<br>
	 * storing some data in FACE->extra.  If successful, return 0.<br>
	 * Otherwise, return -1.<br>
	 * C type : prepare_face_callback
	 */
	@Field(9) 
	public Pointer<font_driver.prepare_face_callback > prepare_face() {
		return this.io.getPointerField(this, 9);
	}
	/**
	 * Optional (if FACE->extra is not used).<br>
	 * Prepare FACE for displaying characters by FONT on frame F by<br>
	 * storing some data in FACE->extra.  If successful, return 0.<br>
	 * Otherwise, return -1.<br>
	 * C type : prepare_face_callback
	 */
	@Field(9) 
	public font_driver prepare_face(Pointer<font_driver.prepare_face_callback > prepare_face) {
		this.io.setPointerField(this, 9, prepare_face);
		return this;
	}
	/**
	 * Optional.<br>
	 * Done FACE for displaying characters by FACE->font on frame F.<br>
	 * C type : done_face_callback
	 */
	@Field(10) 
	public Pointer<font_driver.done_face_callback > done_face() {
		return this.io.getPointerField(this, 10);
	}
	/**
	 * Optional.<br>
	 * Done FACE for displaying characters by FACE->font on frame F.<br>
	 * C type : done_face_callback
	 */
	@Field(10) 
	public font_driver done_face(Pointer<font_driver.done_face_callback > done_face) {
		this.io.setPointerField(this, 10, done_face);
		return this;
	}
	/**
	 * Optional.<br>
	 * If FONT (FONT-ENTITY or FONT-OBJECT) has a glyph for character C<br>
	 * (Unicode code point), return 1.  If not, return 0.  If FONT is<br>
	 * FONT-ENTITY and it must be opened to check it, return -1.<br>
	 * C type : has_char_callback
	 */
	@Field(11) 
	public Pointer<font_driver.has_char_callback > has_char() {
		return this.io.getPointerField(this, 11);
	}
	/**
	 * Optional.<br>
	 * If FONT (FONT-ENTITY or FONT-OBJECT) has a glyph for character C<br>
	 * (Unicode code point), return 1.  If not, return 0.  If FONT is<br>
	 * FONT-ENTITY and it must be opened to check it, return -1.<br>
	 * C type : has_char_callback
	 */
	@Field(11) 
	public font_driver has_char(Pointer<font_driver.has_char_callback > has_char) {
		this.io.setPointerField(this, 11, has_char);
		return this;
	}
	/**
	 * Return a glyph code of FONT for character C (Unicode code point).<br>
	 * If FONT doesn't have such a glyph, return FONT_INVALID_CODE.<br>
	 * C type : encode_char_callback
	 */
	@Field(12) 
	public Pointer<font_driver.encode_char_callback > encode_char() {
		return this.io.getPointerField(this, 12);
	}
	/**
	 * Return a glyph code of FONT for character C (Unicode code point).<br>
	 * If FONT doesn't have such a glyph, return FONT_INVALID_CODE.<br>
	 * C type : encode_char_callback
	 */
	@Field(12) 
	public font_driver encode_char(Pointer<font_driver.encode_char_callback > encode_char) {
		this.io.setPointerField(this, 12, encode_char);
		return this;
	}
	/**
	 * Compute the total metrics of the NGLYPHS glyphs specified by<br>
	 * the font FONT and the sequence of glyph codes CODE, and store the<br>
	 * result in METRICS.<br>
	 * C type : text_extents_callback
	 */
	@Field(13) 
	public Pointer<font_driver.text_extents_callback > text_extents() {
		return this.io.getPointerField(this, 13);
	}
	/**
	 * Compute the total metrics of the NGLYPHS glyphs specified by<br>
	 * the font FONT and the sequence of glyph codes CODE, and store the<br>
	 * result in METRICS.<br>
	 * C type : text_extents_callback
	 */
	@Field(13) 
	public font_driver text_extents(Pointer<font_driver.text_extents_callback > text_extents) {
		this.io.setPointerField(this, 13, text_extents);
		return this;
	}
	/**
	 * Optional.<br>
	 * Draw glyphs between FROM and TO of S->char2b at (X Y) pixel<br>
	 * position of frame F with S->FACE and S->GC.  If WITH_BACKGROUND<br>
	 * is nonzero, fill the background in advance.  It is assured that<br>
	 * WITH_BACKGROUND is zero when (FROM > 0 || TO < S->nchars).<br>
	 * C type : draw_callback
	 */
	@Field(14) 
	public Pointer<font_driver.draw_callback > draw() {
		return this.io.getPointerField(this, 14);
	}
	/**
	 * Optional.<br>
	 * Draw glyphs between FROM and TO of S->char2b at (X Y) pixel<br>
	 * position of frame F with S->FACE and S->GC.  If WITH_BACKGROUND<br>
	 * is nonzero, fill the background in advance.  It is assured that<br>
	 * WITH_BACKGROUND is zero when (FROM > 0 || TO < S->nchars).<br>
	 * C type : draw_callback
	 */
	@Field(14) 
	public font_driver draw(Pointer<font_driver.draw_callback > draw) {
		this.io.setPointerField(this, 14, draw);
		return this;
	}
	/**
	 * Optional.<br>
	 * Store bitmap data for glyph-code CODE of FONT in BITMAP.  It is<br>
	 * intended that this method is called from the other font-driver<br>
	 * for actual drawing.<br>
	 * C type : get_bitmap_callback
	 */
	@Field(15) 
	public Pointer<font_driver.get_bitmap_callback > get_bitmap() {
		return this.io.getPointerField(this, 15);
	}
	/**
	 * Optional.<br>
	 * Store bitmap data for glyph-code CODE of FONT in BITMAP.  It is<br>
	 * intended that this method is called from the other font-driver<br>
	 * for actual drawing.<br>
	 * C type : get_bitmap_callback
	 */
	@Field(15) 
	public font_driver get_bitmap(Pointer<font_driver.get_bitmap_callback > get_bitmap) {
		this.io.setPointerField(this, 15, get_bitmap);
		return this;
	}
	/**
	 * Optional.<br>
	 * Free bitmap data in BITMAP.<br>
	 * C type : free_bitmap_callback
	 */
	@Field(16) 
	public Pointer<font_driver.free_bitmap_callback > free_bitmap() {
		return this.io.getPointerField(this, 16);
	}
	/**
	 * Optional.<br>
	 * Free bitmap data in BITMAP.<br>
	 * C type : free_bitmap_callback
	 */
	@Field(16) 
	public font_driver free_bitmap(Pointer<font_driver.free_bitmap_callback > free_bitmap) {
		this.io.setPointerField(this, 16, free_bitmap);
		return this;
	}
	/**
	 * Optional.<br>
	 * Return an outline data for glyph-code CODE of FONT.  The format<br>
	 * of the outline data depends on the font-driver.<br>
	 * C type : get_outline_callback
	 */
	@Field(17) 
	public Pointer<font_driver.get_outline_callback > get_outline() {
		return this.io.getPointerField(this, 17);
	}
	/**
	 * Optional.<br>
	 * Return an outline data for glyph-code CODE of FONT.  The format<br>
	 * of the outline data depends on the font-driver.<br>
	 * C type : get_outline_callback
	 */
	@Field(17) 
	public font_driver get_outline(Pointer<font_driver.get_outline_callback > get_outline) {
		this.io.setPointerField(this, 17, get_outline);
		return this;
	}
	/**
	 * Optional.<br>
	 * Free OUTLINE (that is obtained by the above method).<br>
	 * C type : free_outline_callback
	 */
	@Field(18) 
	public Pointer<font_driver.free_outline_callback > free_outline() {
		return this.io.getPointerField(this, 18);
	}
	/**
	 * Optional.<br>
	 * Free OUTLINE (that is obtained by the above method).<br>
	 * C type : free_outline_callback
	 */
	@Field(18) 
	public font_driver free_outline(Pointer<font_driver.free_outline_callback > free_outline) {
		this.io.setPointerField(this, 18, free_outline);
		return this;
	}
	/**
	 * Optional.<br>
	 * Get coordinates of the INDEXth anchor point of the glyph whose<br>
	 * code is CODE.  Store the coordinates in *X and *Y.  Return 0 if<br>
	 * the operations was successful.  Otherwise return -1.<br>
	 * C type : anchor_point_callback
	 */
	@Field(19) 
	public Pointer<font_driver.anchor_point_callback > anchor_point() {
		return this.io.getPointerField(this, 19);
	}
	/**
	 * Optional.<br>
	 * Get coordinates of the INDEXth anchor point of the glyph whose<br>
	 * code is CODE.  Store the coordinates in *X and *Y.  Return 0 if<br>
	 * the operations was successful.  Otherwise return -1.<br>
	 * C type : anchor_point_callback
	 */
	@Field(19) 
	public font_driver anchor_point(Pointer<font_driver.anchor_point_callback > anchor_point) {
		this.io.setPointerField(this, 19, anchor_point);
		return this;
	}
	/**
	 * Optional.<br>
	 * Return a list describing which scripts/languages FONT<br>
	 * supports by which GSUB/GPOS features of OpenType tables.<br>
	 * C type : otf_capability_callback
	 */
	@Field(20) 
	public Pointer<font_driver.otf_capability_callback > otf_capability() {
		return this.io.getPointerField(this, 20);
	}
	/**
	 * Optional.<br>
	 * Return a list describing which scripts/languages FONT<br>
	 * supports by which GSUB/GPOS features of OpenType tables.<br>
	 * C type : otf_capability_callback
	 */
	@Field(20) 
	public font_driver otf_capability(Pointer<font_driver.otf_capability_callback > otf_capability) {
		this.io.setPointerField(this, 20, otf_capability);
		return this;
	}
	/**
	 * Optional.<br>
	 * Apply FONT's OTF-FEATURES to the glyph string.<br>
	 * FEATURES specifies which OTF features to apply in this format:<br>
	 * (SCRIPT LANGSYS GSUB-FEATURE GPOS-FEATURE)<br>
	 * See the documentation of `font-drive-otf' for the details.<br>
	 * This method applies the specified features to the codes in the<br>
	 * elements of GSTRING-IN (between FROMth and TOth).  The output<br>
	 * codes are stored in GSTRING-OUT at the IDXth element and the<br>
	 * following elements.<br>
	 * Return the number of output codes.  If none of the features are<br>
	 * applicable to the input data, return 0.  If GSTRING-OUT is too<br>
	 * short, return -1.<br>
	 * C type : otf_drive_callback
	 */
	@Field(21) 
	public Pointer<font_driver.otf_drive_callback > otf_drive() {
		return this.io.getPointerField(this, 21);
	}
	/**
	 * Optional.<br>
	 * Apply FONT's OTF-FEATURES to the glyph string.<br>
	 * FEATURES specifies which OTF features to apply in this format:<br>
	 * (SCRIPT LANGSYS GSUB-FEATURE GPOS-FEATURE)<br>
	 * See the documentation of `font-drive-otf' for the details.<br>
	 * This method applies the specified features to the codes in the<br>
	 * elements of GSTRING-IN (between FROMth and TOth).  The output<br>
	 * codes are stored in GSTRING-OUT at the IDXth element and the<br>
	 * following elements.<br>
	 * Return the number of output codes.  If none of the features are<br>
	 * applicable to the input data, return 0.  If GSTRING-OUT is too<br>
	 * short, return -1.<br>
	 * C type : otf_drive_callback
	 */
	@Field(21) 
	public font_driver otf_drive(Pointer<font_driver.otf_drive_callback > otf_drive) {
		this.io.setPointerField(this, 21, otf_drive);
		return this;
	}
	/**
	 * Optional.<br>
	 * Make the font driver ready for frame F.  Usually this function<br>
	 * makes some data specific to F and stores it in F by calling<br>
	 * font_put_frame_data ().<br>
	 * C type : start_for_frame_callback
	 */
	@Field(22) 
	public Pointer<font_driver.start_for_frame_callback > start_for_frame() {
		return this.io.getPointerField(this, 22);
	}
	/**
	 * Optional.<br>
	 * Make the font driver ready for frame F.  Usually this function<br>
	 * makes some data specific to F and stores it in F by calling<br>
	 * font_put_frame_data ().<br>
	 * C type : start_for_frame_callback
	 */
	@Field(22) 
	public font_driver start_for_frame(Pointer<font_driver.start_for_frame_callback > start_for_frame) {
		this.io.setPointerField(this, 22, start_for_frame);
		return this;
	}
	/**
	 * Optional.<br>
	 * End using the driver for frame F.  Usually this function free<br>
	 * some data stored for F.<br>
	 * C type : end_for_frame_callback
	 */
	@Field(23) 
	public Pointer<font_driver.end_for_frame_callback > end_for_frame() {
		return this.io.getPointerField(this, 23);
	}
	/**
	 * Optional.<br>
	 * End using the driver for frame F.  Usually this function free<br>
	 * some data stored for F.<br>
	 * C type : end_for_frame_callback
	 */
	@Field(23) 
	public font_driver end_for_frame(Pointer<font_driver.end_for_frame_callback > end_for_frame) {
		this.io.setPointerField(this, 23, end_for_frame);
		return this;
	}
	/**
	 * Optional.<br>
	 * Shape text in GSTRING.  See the docstring of<br>
	 * `composition-get-gstring' for the format of GSTRING.  If the<br>
	 * (N+1)th element of GSTRING is nil, input of shaping is from the<br>
	 * 1st to (N)th elements.  In each input glyph, FROM, TO, CHAR, and<br>
	 * CODE are already set.<br>
	 * This function updates all fields of the input glyphs.  If the<br>
	 * output glyphs (M) are more than the input glyphs (N), (N+1)th<br>
	 * through (M)th elements of GSTRING are updated possibly by making<br>
	 * a new glyph object and storing it in GSTRING.  If (M) is greater<br>
	 * than the length of GSTRING, nil should be return.  In that case,<br>
	 * this function is called again with the larger GSTRING.<br>
	 * C type : shape_callback
	 */
	@Field(24) 
	public Pointer<font_driver.shape_callback > shape() {
		return this.io.getPointerField(this, 24);
	}
	/**
	 * Optional.<br>
	 * Shape text in GSTRING.  See the docstring of<br>
	 * `composition-get-gstring' for the format of GSTRING.  If the<br>
	 * (N+1)th element of GSTRING is nil, input of shaping is from the<br>
	 * 1st to (N)th elements.  In each input glyph, FROM, TO, CHAR, and<br>
	 * CODE are already set.<br>
	 * This function updates all fields of the input glyphs.  If the<br>
	 * output glyphs (M) are more than the input glyphs (N), (N+1)th<br>
	 * through (M)th elements of GSTRING are updated possibly by making<br>
	 * a new glyph object and storing it in GSTRING.  If (M) is greater<br>
	 * than the length of GSTRING, nil should be return.  In that case,<br>
	 * this function is called again with the larger GSTRING.<br>
	 * C type : shape_callback
	 */
	@Field(24) 
	public font_driver shape(Pointer<font_driver.shape_callback > shape) {
		this.io.setPointerField(this, 24, shape);
		return this;
	}
	/**
	 * Optional.<br>
	 * If FONT is usable on frame F, return 0.  Otherwise return -1.<br>
	 * This method is used only for debugging.  If this method is NULL,<br>
	 * Emacs assumes that the font is usable on any frame.<br>
	 * C type : check_callback
	 */
	@Field(25) 
	public Pointer<font_driver.check_callback > check() {
		return this.io.getPointerField(this, 25);
	}
	/**
	 * Optional.<br>
	 * If FONT is usable on frame F, return 0.  Otherwise return -1.<br>
	 * This method is used only for debugging.  If this method is NULL,<br>
	 * Emacs assumes that the font is usable on any frame.<br>
	 * C type : check_callback
	 */
	@Field(25) 
	public font_driver check(Pointer<font_driver.check_callback > check) {
		this.io.setPointerField(this, 25, check);
		return this;
	}
	/**
	 * Optional.<br>
	 * Return the number of variation glyphs of character C supported by<br>
	 * FONT.  VARIATIONS is an array of 256 elements.  If the variation<br>
	 * selector N (1..256) defines a glyph, that glyph code is stored in<br>
	 * the (N-1)th element of VARIATIONS.<br>
	 * C type : get_variation_glyphs_callback
	 */
	@Field(26) 
	public Pointer<font_driver.get_variation_glyphs_callback > get_variation_glyphs() {
		return this.io.getPointerField(this, 26);
	}
	/**
	 * Optional.<br>
	 * Return the number of variation glyphs of character C supported by<br>
	 * FONT.  VARIATIONS is an array of 256 elements.  If the variation<br>
	 * selector N (1..256) defines a glyph, that glyph code is stored in<br>
	 * the (N-1)th element of VARIATIONS.<br>
	 * C type : get_variation_glyphs_callback
	 */
	@Field(26) 
	public font_driver get_variation_glyphs(Pointer<font_driver.get_variation_glyphs_callback > get_variation_glyphs) {
		this.io.setPointerField(this, 26, get_variation_glyphs);
		return this;
	}
	/// C type : filter_properties_callback
	@Field(27) 
	public Pointer<font_driver.filter_properties_callback > filter_properties() {
		return this.io.getPointerField(this, 27);
	}
	/// C type : filter_properties_callback
	@Field(27) 
	public font_driver filter_properties(Pointer<font_driver.filter_properties_callback > filter_properties) {
		this.io.setPointerField(this, 27, filter_properties);
		return this;
	}
	/**
	 * Optional.<br>
	 * Return non-zero if FONT_OBJECT can be used as a (cached) font<br>
	 * for ENTITY on frame F.<br>
	 * C type : cached_font_ok_callback
	 */
	@Field(28) 
	public Pointer<font_driver.cached_font_ok_callback > cached_font_ok() {
		return this.io.getPointerField(this, 28);
	}
	/**
	 * Optional.<br>
	 * Return non-zero if FONT_OBJECT can be used as a (cached) font<br>
	 * for ENTITY on frame F.<br>
	 * C type : cached_font_ok_callback
	 */
	@Field(28) 
	public font_driver cached_font_ok(Pointer<font_driver.cached_font_ok_callback > cached_font_ok) {
		this.io.setPointerField(this, 28, cached_font_ok);
		return this;
	}
	/// <i>native declaration : font.h:547</i>
	/// <i>native declaration : font.h:547</i>
	public static abstract class get_cache_callback extends Callback<get_cache_callback > {
		public abstract Lisp_Object apply(FRAME_PTR F);
	};
	/// <i>native declaration : font.h:548</i>
	/// <i>native declaration : font.h:548</i>
	public static abstract class list_callback extends Callback<list_callback > {
		public abstract Lisp_Object apply(Lisp_Object frame, Lisp_Object font_spec);
	};
	/// <i>native declaration : font.h:549</i>
	/// <i>native declaration : font.h:549</i>
	public static abstract class match_callback extends Callback<match_callback > {
		public abstract Lisp_Object apply(Lisp_Object frame, Lisp_Object font_spec);
	};
	/// <i>native declaration : font.h:550</i>
	/// <i>native declaration : font.h:550</i>
	public static abstract class list_family_callback extends Callback<list_family_callback > {
		public abstract Lisp_Object apply(Lisp_Object frame);
	};
	/// <i>native declaration : font.h:551</i>
	/// <i>native declaration : font.h:551</i>
	public static abstract class free_entity_callback extends Callback<free_entity_callback > {
		public abstract void apply(Lisp_Object font_entity);
	};
	/// <i>native declaration : font.h:552</i>
	/// <i>native declaration : font.h:552</i>
	public static abstract class open_callback extends Callback<open_callback > {
		public abstract Lisp_Object apply(FRAME_PTR f, Lisp_Object font_entity, int pixel_size);
	};
	/// <i>native declaration : font.h:553</i>
	/// <i>native declaration : font.h:553</i>
	public static abstract class close_callback extends Callback<close_callback > {
		public abstract void apply(FRAME_PTR f, Pointer<font > font);
	};
	/// <i>native declaration : font.h:554</i>
	/// <i>native declaration : font.h:554</i>
	public static abstract class prepare_face_callback extends Callback<prepare_face_callback > {
		public abstract int apply(FRAME_PTR f, Pointer<face > face);
	};
	/// <i>native declaration : font.h:555</i>
	/// <i>native declaration : font.h:555</i>
	public static abstract class done_face_callback extends Callback<done_face_callback > {
		public abstract void apply(FRAME_PTR f, Pointer<face > face);
	};
	/// <i>native declaration : font.h:556</i>
	/// <i>native declaration : font.h:556</i>
	public static abstract class has_char_callback extends Callback<has_char_callback > {
		public abstract int apply(Lisp_Object font, int c);
	};
	/// <i>native declaration : font.h:557</i>
	/// <i>native declaration : font.h:557</i>
	public static abstract class encode_char_callback extends Callback<encode_char_callback > {
		public abstract int apply(Pointer<font > font, int c);
	};
	/// <i>native declaration : font.h:558</i>
	/// <i>native declaration : font.h:558</i>
	public static abstract class text_extents_callback extends Callback<text_extents_callback > {
		public abstract int apply(Pointer<font > font, Pointer<Integer > code, int nglyphs, Pointer<font_metrics > metrics);
	};
	/// <i>native declaration : font.h:559</i>
	/// <i>native declaration : font.h:559</i>
	public static abstract class draw_callback extends Callback<draw_callback > {
		public abstract int apply(Pointer<glyph_string > s, int from, int to, int x, int y, int with_background);
	};
	/// <i>native declaration : font.h:560</i>
	/// <i>native declaration : font.h:560</i>
	public static abstract class get_bitmap_callback extends Callback<get_bitmap_callback > {
		public abstract int apply(Pointer<font > font, int code, Pointer<font_bitmap > bitmap, int bits_per_pixel);
	};
	/// <i>native declaration : font.h:561</i>
	/// <i>native declaration : font.h:561</i>
	public static abstract class free_bitmap_callback extends Callback<free_bitmap_callback > {
		public abstract void apply(Pointer<font > font, Pointer<font_bitmap > bitmap);
	};
	/// <i>native declaration : font.h:562</i>
	/// <i>native declaration : font.h:562</i>
	public static abstract class get_outline_callback extends Callback<get_outline_callback > {
		public abstract Pointer<? > apply(Pointer<font > font, int code);
	};
	/// <i>native declaration : font.h:563</i>
	/// <i>native declaration : font.h:563</i>
	public static abstract class free_outline_callback extends Callback<free_outline_callback > {
		public abstract void apply(Pointer<font > font, Pointer<? > outline);
	};
	/// <i>native declaration : font.h:564</i>
	/// <i>native declaration : font.h:564</i>
	public static abstract class anchor_point_callback extends Callback<anchor_point_callback > {
		public abstract int apply(Pointer<font > font, int code, int index, Pointer<Integer > x, Pointer<Integer > y);
	};
	/// <i>native declaration : font.h:565</i>
	/// <i>native declaration : font.h:565</i>
	public static abstract class otf_capability_callback extends Callback<otf_capability_callback > {
		public abstract Lisp_Object apply(Pointer<font > font);
	};
	/// <i>native declaration : font.h:566</i>
	/// <i>native declaration : font.h:566</i>
	public static abstract class otf_drive_callback extends Callback<otf_drive_callback > {
		public abstract int apply(Pointer<font > font, Lisp_Object features, Lisp_Object gstring_in, int from, int to, Lisp_Object gstring_out, int idx, int alternate_subst);
	};
	/// <i>native declaration : font.h:567</i>
	/// <i>native declaration : font.h:567</i>
	public static abstract class start_for_frame_callback extends Callback<start_for_frame_callback > {
		public abstract int apply(FRAME_PTR f);
	};
	/// <i>native declaration : font.h:568</i>
	/// <i>native declaration : font.h:568</i>
	public static abstract class end_for_frame_callback extends Callback<end_for_frame_callback > {
		public abstract int apply(FRAME_PTR f);
	};
	/// <i>native declaration : font.h:569</i>
	/// <i>native declaration : font.h:569</i>
	public static abstract class shape_callback extends Callback<shape_callback > {
		public abstract Lisp_Object apply(Lisp_Object lgstring);
	};
	/// <i>native declaration : font.h:570</i>
	/// <i>native declaration : font.h:570</i>
	public static abstract class check_callback extends Callback<check_callback > {
		public abstract int apply(FRAME_PTR F, Pointer<font > font);
	};
	/// <i>native declaration : font.h:571</i>
	/// <i>native declaration : font.h:571</i>
	public static abstract class get_variation_glyphs_callback extends Callback<get_variation_glyphs_callback > {
		public abstract int apply(Pointer<font > font, int c, Pointer<Integer > variations);
	};
	/// <i>native declaration : font.h:572</i>
	/// <i>native declaration : font.h:572</i>
	public static abstract class filter_properties_callback extends Callback<filter_properties_callback > {
		public abstract void apply(Lisp_Object font, Lisp_Object properties);
	};
	/// <i>native declaration : font.h:573</i>
	/// <i>native declaration : font.h:573</i>
	public static abstract class cached_font_ok_callback extends Callback<cached_font_ok_callback > {
		public abstract int apply(Pointer<frame > f, Lisp_Object font_object, Lisp_Object entity);
	};
}
