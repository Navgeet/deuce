package emacs.w32term;
import emacs.w32term.W32termLibrary.frame;
import emacs.w32term.W32termLibrary.terminal;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
import org.bridj.ann.Ptr;
/**
 * <i>native declaration : w32term.h:452</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("w32term") 
public class w32_display_info extends StructObject {
	public w32_display_info() {
		super();
	}
	/**
	 * Chain of all w32_display_info structures.<br>
	 * C type : w32_display_info*
	 */
	@Field(0) 
	public Pointer<w32_display_info > next() {
		return this.io.getPointerField(this, 0);
	}
	/**
	 * Chain of all w32_display_info structures.<br>
	 * C type : w32_display_info*
	 */
	@Field(0) 
	public w32_display_info next(Pointer<w32_display_info > next) {
		this.io.setPointerField(this, 0, next);
		return this;
	}
	/**
	 * The generic display parameters corresponding to this w32 display.<br>
	 * C type : terminal*
	 */
	@Field(1) 
	public Pointer<terminal > terminal() {
		return this.io.getPointerField(this, 1);
	}
	/**
	 * The generic display parameters corresponding to this w32 display.<br>
	 * C type : terminal*
	 */
	@Field(1) 
	public w32_display_info terminal(Pointer<terminal > terminal) {
		this.io.setPointerField(this, 1, terminal);
		return this;
	}
	/// Number of frames that are on this display.
	@Field(3) 
	public int reference_count() {
		return this.io.getIntField(this, 3);
	}
	/// Number of frames that are on this display.
	@Field(3) 
	public w32_display_info reference_count(int reference_count) {
		this.io.setIntField(this, 3, reference_count);
		return this;
	}
	/// Dots per inch of the screen.
	@Field(4) 
	public double resx() {
		return this.io.getDoubleField(this, 4);
	}
	/// Dots per inch of the screen.
	@Field(4) 
	public w32_display_info resx(double resx) {
		this.io.setDoubleField(this, 4, resx);
		return this;
	}
	/// Dots per inch of the screen.
	@Field(5) 
	public double resy() {
		return this.io.getDoubleField(this, 5);
	}
	/// Dots per inch of the screen.
	@Field(5) 
	public w32_display_info resy(double resy) {
		this.io.setDoubleField(this, 5, resy);
		return this;
	}
	/// Number of planes on this screen.
	@Field(6) 
	public int n_planes() {
		return this.io.getIntField(this, 6);
	}
	/// Number of planes on this screen.
	@Field(6) 
	public w32_display_info n_planes(int n_planes) {
		this.io.setIntField(this, 6, n_planes);
		return this;
	}
	/// Number of bits per pixel on this screen.
	@Field(7) 
	public int n_cbits() {
		return this.io.getIntField(this, 7);
	}
	/// Number of bits per pixel on this screen.
	@Field(7) 
	public w32_display_info n_cbits(int n_cbits) {
		this.io.setIntField(this, 7, n_cbits);
		return this;
	}
	/// Mask of things that cause the mouse to be grabbed.
	@Field(8) 
	public int grabbed() {
		return this.io.getIntField(this, 8);
	}
	/// Mask of things that cause the mouse to be grabbed.
	@Field(8) 
	public w32_display_info grabbed(int grabbed) {
		this.io.setIntField(this, 8, grabbed);
		return this;
	}
	/**
	 * Emacs bitmap-id of the default icon bitmap for this frame.<br>
	 * Or -1 if none has been allocated yet.
	 */
	@Ptr 
	@Field(9) 
	public long icon_bitmap_id() {
		return this.io.getSizeTField(this, 9);
	}
	/**
	 * Emacs bitmap-id of the default icon bitmap for this frame.<br>
	 * Or -1 if none has been allocated yet.
	 */
	@Ptr 
	@Field(9) 
	public w32_display_info icon_bitmap_id(long icon_bitmap_id) {
		this.io.setSizeTField(this, 9, icon_bitmap_id);
		return this;
	}
	/**
	 * Resource data base<br>
	 * C type : XrmDatabase
	 */
	@Field(12) 
	public Pointer<Byte > xrdb() {
		return this.io.getPointerField(this, 12);
	}
	/**
	 * Resource data base<br>
	 * C type : XrmDatabase
	 */
	@Field(12) 
	public w32_display_info xrdb(Pointer<Byte > xrdb) {
		this.io.setPointerField(this, 12, xrdb);
		return this;
	}
	/// color palette information.
	@Field(13) 
	public int has_palette() {
		return this.io.getIntField(this, 13);
	}
	/// color palette information.
	@Field(13) 
	public w32_display_info has_palette(int has_palette) {
		this.io.setIntField(this, 13, has_palette);
		return this;
	}
	/// C type : w32_palette_entry*
	@Field(14) 
	public Pointer<w32_palette_entry > color_list() {
		return this.io.getPointerField(this, 14);
	}
	/// C type : w32_palette_entry*
	@Field(14) 
	public w32_display_info color_list(Pointer<w32_palette_entry > color_list) {
		this.io.setPointerField(this, 14, color_list);
		return this;
	}
	@Field(15) 
	public int num_colors() {
		return this.io.getIntField(this, 15);
	}
	@Field(15) 
	public w32_display_info num_colors(int num_colors) {
		this.io.setIntField(this, 15, num_colors);
		return this;
	}
	/// deferred action flags checked when starting frame update.
	@Field(17) 
	public int regen_palette() {
		return this.io.getIntField(this, 17);
	}
	/// deferred action flags checked when starting frame update.
	@Field(17) 
	public w32_display_info regen_palette(int regen_palette) {
		this.io.setIntField(this, 17, regen_palette);
		return this;
	}
	/**
	 * Keystroke that has been faked by Emacs and will be ignored when<br>
	 * received; value is reset after key is received.
	 */
	@Field(18) 
	public int faked_key() {
		return this.io.getIntField(this, 18);
	}
	/**
	 * Keystroke that has been faked by Emacs and will be ignored when<br>
	 * received; value is reset after key is received.
	 */
	@Field(18) 
	public w32_display_info faked_key(int faked_key) {
		this.io.setIntField(this, 18, faked_key);
		return this;
	}
	/// Minimum width over all characters in all fonts in font_table.
	@Field(19) 
	public int smallest_char_width() {
		return this.io.getIntField(this, 19);
	}
	/// Minimum width over all characters in all fonts in font_table.
	@Field(19) 
	public w32_display_info smallest_char_width(int smallest_char_width) {
		this.io.setIntField(this, 19, smallest_char_width);
		return this;
	}
	/// Minimum font height over all fonts in font_table.
	@Field(20) 
	public int smallest_font_height() {
		return this.io.getIntField(this, 20);
	}
	/// Minimum font height over all fonts in font_table.
	@Field(20) 
	public w32_display_info smallest_font_height(int smallest_font_height) {
		this.io.setIntField(this, 20, smallest_font_height);
		return this;
	}
	/**
	 * Reusable Graphics Context for drawing a cursor in a non-default face.<br>
	 * C type : XGCValues*
	 */
	@Field(21) 
	public Pointer<XGCValues > scratch_cursor_gc() {
		return this.io.getPointerField(this, 21);
	}
	/**
	 * Reusable Graphics Context for drawing a cursor in a non-default face.<br>
	 * C type : XGCValues*
	 */
	@Field(21) 
	public w32_display_info scratch_cursor_gc(Pointer<XGCValues > scratch_cursor_gc) {
		this.io.setPointerField(this, 21, scratch_cursor_gc);
		return this;
	}
	/// C type : char*
	@Field(23) 
	public Pointer<Byte > w32_id_name() {
		return this.io.getPointerField(this, 23);
	}
	/// C type : char*
	@Field(23) 
	public w32_display_info w32_id_name(Pointer<Byte > w32_id_name) {
		this.io.setPointerField(this, 23, w32_id_name);
		return this;
	}
	/**
	 * The number of fonts actually stored in w32_font_table.<br>
	 * font_table[n] is used and valid if 0 <= n < n_fonts. 0 <=<br>
	 * n_fonts <= font_table_size. and font_table[i].name != 0.
	 */
	@Field(24) 
	public int n_fonts() {
		return this.io.getIntField(this, 24);
	}
	/**
	 * The number of fonts actually stored in w32_font_table.<br>
	 * font_table[n] is used and valid if 0 <= n < n_fonts. 0 <=<br>
	 * n_fonts <= font_table_size. and font_table[i].name != 0.
	 */
	@Field(24) 
	public w32_display_info n_fonts(int n_fonts) {
		this.io.setIntField(this, 24, n_fonts);
		return this;
	}
	/**
	 * Pointer to bitmap records.<br>
	 * C type : w32_bitmap_record*
	 */
	@Field(25) 
	public Pointer<w32_bitmap_record > bitmaps() {
		return this.io.getPointerField(this, 25);
	}
	/**
	 * Pointer to bitmap records.<br>
	 * C type : w32_bitmap_record*
	 */
	@Field(25) 
	public w32_display_info bitmaps(Pointer<w32_bitmap_record > bitmaps) {
		this.io.setPointerField(this, 25, bitmaps);
		return this;
	}
	/// Allocated size of bitmaps field.
	@Ptr 
	@Field(26) 
	public long bitmaps_size() {
		return this.io.getSizeTField(this, 26);
	}
	/// Allocated size of bitmaps field.
	@Ptr 
	@Field(26) 
	public w32_display_info bitmaps_size(long bitmaps_size) {
		this.io.setSizeTField(this, 26, bitmaps_size);
		return this;
	}
	/// Last used bitmap index.
	@Ptr 
	@Field(27) 
	public long bitmaps_last() {
		return this.io.getSizeTField(this, 27);
	}
	/// Last used bitmap index.
	@Ptr 
	@Field(27) 
	public w32_display_info bitmaps_last(long bitmaps_last) {
		this.io.setSizeTField(this, 27, bitmaps_last);
		return this;
	}
	/**
	 * The frame (if any) which has the window that has keyboard focus.<br>
	 * Zero if none.  This is examined by Ffocus_frame in w32fns.c.  Note<br>
	 * that a mere EnterNotify event can set this; if you need to know the<br>
	 * last frame specified in a FocusIn or FocusOut event, use<br>
	 * w32_focus_event_frame.<br>
	 * C type : frame*
	 */
	@Field(28) 
	public Pointer<frame > w32_focus_frame() {
		return this.io.getPointerField(this, 28);
	}
	/**
	 * The frame (if any) which has the window that has keyboard focus.<br>
	 * Zero if none.  This is examined by Ffocus_frame in w32fns.c.  Note<br>
	 * that a mere EnterNotify event can set this; if you need to know the<br>
	 * last frame specified in a FocusIn or FocusOut event, use<br>
	 * w32_focus_event_frame.<br>
	 * C type : frame*
	 */
	@Field(28) 
	public w32_display_info w32_focus_frame(Pointer<frame > w32_focus_frame) {
		this.io.setPointerField(this, 28, w32_focus_frame);
		return this;
	}
	/**
	 * The last frame mentioned in a FocusIn or FocusOut event.  This is<br>
	 * separate from w32_focus_frame, because whether or not LeaveNotify<br>
	 * events cause us to lose focus depends on whether or not we have<br>
	 * received a FocusIn event for it.<br>
	 * C type : frame*
	 */
	@Field(29) 
	public Pointer<frame > w32_focus_event_frame() {
		return this.io.getPointerField(this, 29);
	}
	/**
	 * The last frame mentioned in a FocusIn or FocusOut event.  This is<br>
	 * separate from w32_focus_frame, because whether or not LeaveNotify<br>
	 * events cause us to lose focus depends on whether or not we have<br>
	 * received a FocusIn event for it.<br>
	 * C type : frame*
	 */
	@Field(29) 
	public w32_display_info w32_focus_event_frame(Pointer<frame > w32_focus_event_frame) {
		this.io.setPointerField(this, 29, w32_focus_event_frame);
		return this;
	}
	/**
	 * The frame which currently has the visual highlight, and should get<br>
	 * keyboard input (other sorts of input have the frame encoded in the<br>
	 * event).  It points to the focus frame's selected window's<br>
	 * frame.  It differs from w32_focus_frame when we're using a global<br>
	 * minibuffer.<br>
	 * C type : frame*
	 */
	@Field(30) 
	public Pointer<frame > x_highlight_frame() {
		return this.io.getPointerField(this, 30);
	}
	/**
	 * The frame which currently has the visual highlight, and should get<br>
	 * keyboard input (other sorts of input have the frame encoded in the<br>
	 * event).  It points to the focus frame's selected window's<br>
	 * frame.  It differs from w32_focus_frame when we're using a global<br>
	 * minibuffer.<br>
	 * C type : frame*
	 */
	@Field(30) 
	public w32_display_info x_highlight_frame(Pointer<frame > x_highlight_frame) {
		this.io.setPointerField(this, 30, x_highlight_frame);
		return this;
	}
}
