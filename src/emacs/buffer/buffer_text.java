package emacs.buffer;
import emacs.buffer.BufferLibrary.Lisp_Marker;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
/**
 * <i>native declaration : buffer.h:348</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("buffer") 
public class buffer_text extends StructObject {
	public buffer_text() {
		super();
	}
	/**
	 * Actual address of buffer contents.  If REL_ALLOC is defined,<br>
	 * this address might change when blocks are relocated which can<br>
	 * e.g. happen when malloc is called.  So, don't pass a pointer<br>
	 * into a buffer's text to functions that malloc.<br>
	 * C type : unsigned char*
	 */
	@Field(0) 
	public Pointer<Byte > beg() {
		return this.io.getPointerField(this, 0);
	}
	/**
	 * Actual address of buffer contents.  If REL_ALLOC is defined,<br>
	 * this address might change when blocks are relocated which can<br>
	 * e.g. happen when malloc is called.  So, don't pass a pointer<br>
	 * into a buffer's text to functions that malloc.<br>
	 * C type : unsigned char*
	 */
	@Field(0) 
	public buffer_text beg(Pointer<Byte > beg) {
		this.io.setPointerField(this, 0, beg);
		return this;
	}
	/**
	 * This counts buffer-modification events<br>
	 * for this buffer.  It is incremented for<br>
	 * each such event, and never otherwise<br>
	 * changed.
	 */
	@Field(6) 
	public int modiff() {
		return this.io.getIntField(this, 6);
	}
	/**
	 * This counts buffer-modification events<br>
	 * for this buffer.  It is incremented for<br>
	 * each such event, and never otherwise<br>
	 * changed.
	 */
	@Field(6) 
	public buffer_text modiff(int modiff) {
		this.io.setIntField(this, 6, modiff);
		return this;
	}
	/**
	 * This is modified with character change<br>
	 * events for this buffer.  It is set to<br>
	 * modiff for each such event, and never<br>
	 * otherwise changed.
	 */
	@Field(7) 
	public int chars_modiff() {
		return this.io.getIntField(this, 7);
	}
	/**
	 * This is modified with character change<br>
	 * events for this buffer.  It is set to<br>
	 * modiff for each such event, and never<br>
	 * otherwise changed.
	 */
	@Field(7) 
	public buffer_text chars_modiff(int chars_modiff) {
		this.io.setIntField(this, 7, chars_modiff);
		return this;
	}
	/**
	 * Previous value of modiff, as of last<br>
	 * time buffer visited or saved a file.
	 */
	@Field(8) 
	public int save_modiff() {
		return this.io.getIntField(this, 8);
	}
	/**
	 * Previous value of modiff, as of last<br>
	 * time buffer visited or saved a file.
	 */
	@Field(8) 
	public buffer_text save_modiff(int save_modiff) {
		this.io.setIntField(this, 8, save_modiff);
		return this;
	}
	/// Counts modifications to overlays.
	@Field(9) 
	public int overlay_modiff() {
		return this.io.getIntField(this, 9);
	}
	/// Counts modifications to overlays.
	@Field(9) 
	public buffer_text overlay_modiff(int overlay_modiff) {
		this.io.setIntField(this, 9, overlay_modiff);
		return this;
	}
	/**
	 * MODIFF as of last redisplay that finished; if it matches MODIFF,<br>
	 * beg_unchanged and end_unchanged contain no useful information.
	 */
	@Field(12) 
	public int unchanged_modified() {
		return this.io.getIntField(this, 12);
	}
	/**
	 * MODIFF as of last redisplay that finished; if it matches MODIFF,<br>
	 * beg_unchanged and end_unchanged contain no useful information.
	 */
	@Field(12) 
	public buffer_text unchanged_modified(int unchanged_modified) {
		this.io.setIntField(this, 12, unchanged_modified);
		return this;
	}
	/**
	 * BUF_OVERLAY_MODIFF of current buffer, as of last redisplay that<br>
	 * finished; if it matches BUF_OVERLAY_MODIFF, beg_unchanged and<br>
	 * end_unchanged contain no useful information.
	 */
	@Field(13) 
	public int overlay_unchanged_modified() {
		return this.io.getIntField(this, 13);
	}
	/**
	 * BUF_OVERLAY_MODIFF of current buffer, as of last redisplay that<br>
	 * finished; if it matches BUF_OVERLAY_MODIFF, beg_unchanged and<br>
	 * end_unchanged contain no useful information.
	 */
	@Field(13) 
	public buffer_text overlay_unchanged_modified(int overlay_unchanged_modified) {
		this.io.setIntField(this, 13, overlay_unchanged_modified);
		return this;
	}
	/**
	 * The markers that refer to this buffer.<br>
	 * This is actually a single marker ---<br>
	 * successive elements in its marker `chain'<br>
	 * are the other markers referring to this buffer.<br>
	 * This is a singly linked unordered list, which means that it's<br>
	 * very cheap to add a marker to the list and it's also very cheap<br>
	 * to move a marker within a buffer.<br>
	 * C type : Lisp_Marker*
	 */
	@Field(15) 
	public Pointer<Lisp_Marker > markers() {
		return this.io.getPointerField(this, 15);
	}
	/**
	 * The markers that refer to this buffer.<br>
	 * This is actually a single marker ---<br>
	 * successive elements in its marker `chain'<br>
	 * are the other markers referring to this buffer.<br>
	 * This is a singly linked unordered list, which means that it's<br>
	 * very cheap to add a marker to the list and it's also very cheap<br>
	 * to move a marker within a buffer.<br>
	 * C type : Lisp_Marker*
	 */
	@Field(15) 
	public buffer_text markers(Pointer<Lisp_Marker > markers) {
		this.io.setPointerField(this, 15, markers);
		return this;
	}
	/**
	 * Usually 0.  Temporarily set to 1 in decode_coding_gap to<br>
	 * prevent Fgarbage_collect from shrinking the gap and losing<br>
	 * not-yet-decoded bytes.
	 */
	@Field(16) 
	public int inhibit_shrinking() {
		return this.io.getIntField(this, 16);
	}
	/**
	 * Usually 0.  Temporarily set to 1 in decode_coding_gap to<br>
	 * prevent Fgarbage_collect from shrinking the gap and losing<br>
	 * not-yet-decoded bytes.
	 */
	@Field(16) 
	public buffer_text inhibit_shrinking(int inhibit_shrinking) {
		this.io.setIntField(this, 16, inhibit_shrinking);
		return this;
	}
}
