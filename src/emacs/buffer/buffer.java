package emacs.buffer;
import emacs.buffer.BufferLibrary.Lisp_Overlay;
import emacs.buffer.BufferLibrary.region_cache;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Array;
import org.bridj.ann.Bits;
import org.bridj.ann.CLong;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
/**
 * <i>native declaration : buffer.h:725</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("buffer") 
public class buffer extends StructObject {
	public buffer() {
		super();
	}
	/**
	 * This structure holds the coordinates of the buffer contents<br>
	 * in ordinary buffers.  In indirect buffers, this is not used.<br>
	 * C type : buffer_text
	 */
	@Field(1) 
	public buffer_text own_text() {
		return this.io.getNativeObjectField(this, 1);
	}
	/**
	 * This structure holds the coordinates of the buffer contents<br>
	 * in ordinary buffers.  In indirect buffers, this is not used.<br>
	 * C type : buffer_text
	 */
	@Field(1) 
	public buffer own_text(buffer_text own_text) {
		this.io.setNativeObjectField(this, 1, own_text);
		return this;
	}
	/**
	 * This points to the `struct buffer_text' that used for this buffer.<br>
	 * In an ordinary buffer, this is the own_text field above.<br>
	 * In an indirect buffer, this is the own_text field of another buffer.<br>
	 * C type : buffer_text*
	 */
	@Field(2) 
	public Pointer<buffer_text > text() {
		return this.io.getPointerField(this, 2);
	}
	/**
	 * This points to the `struct buffer_text' that used for this buffer.<br>
	 * In an ordinary buffer, this is the own_text field above.<br>
	 * In an indirect buffer, this is the own_text field of another buffer.<br>
	 * C type : buffer_text*
	 */
	@Field(2) 
	public buffer text(Pointer<buffer_text > text) {
		this.io.setPointerField(this, 2, text);
		return this;
	}
	/**
	 * In an indirect buffer, this points to the base buffer.<br>
	 * In an ordinary buffer, it is 0.<br>
	 * C type : buffer*
	 */
	@Field(9) 
	public Pointer<buffer > base_buffer() {
		return this.io.getPointerField(this, 9);
	}
	/**
	 * In an indirect buffer, this points to the base buffer.<br>
	 * In an ordinary buffer, it is 0.<br>
	 * C type : buffer*
	 */
	@Field(9) 
	public buffer base_buffer(Pointer<buffer > base_buffer) {
		this.io.setPointerField(this, 9, base_buffer);
		return this;
	}
	/// C type : char[50]
	@Array({50}) 
	@Field(10) 
	public Pointer<Byte > local_flags() {
		return this.io.getPointerField(this, 10);
	}
	/**
	 * Set to the modtime of the visited file when read or written.<br>
	 * -1 means visited file was nonexistent.<br>
	 * 0 means visited file modtime unknown; in no case complain<br>
	 * about any mismatch on next save attempt.<br>
	 * C type : time_t
	 */
	@CLong 
	@Field(11) 
	public long modtime() {
		return this.io.getCLongField(this, 11);
	}
	/**
	 * Set to the modtime of the visited file when read or written.<br>
	 * -1 means visited file was nonexistent.<br>
	 * 0 means visited file modtime unknown; in no case complain<br>
	 * about any mismatch on next save attempt.<br>
	 * C type : time_t
	 */
	@CLong 
	@Field(11) 
	public buffer modtime(long modtime) {
		this.io.setCLongField(this, 11, modtime);
		return this;
	}
	/**
	 * Size of the file when modtime was set.  This is used to detect the<br>
	 * case where the file grew while we were reading it, so the modtime<br>
	 * is still the same (since it's rounded up to seconds) but we're actually<br>
	 * not up-to-date.  -1 means the size is unknown.  Only meaningful if<br>
	 * modtime is actually set.<br>
	 * C type : off_t
	 */
	@CLong 
	@Field(12) 
	public long modtime_size() {
		return this.io.getCLongField(this, 12);
	}
	/**
	 * Size of the file when modtime was set.  This is used to detect the<br>
	 * case where the file grew while we were reading it, so the modtime<br>
	 * is still the same (since it's rounded up to seconds) but we're actually<br>
	 * not up-to-date.  -1 means the size is unknown.  Only meaningful if<br>
	 * modtime is actually set.<br>
	 * C type : off_t
	 */
	@CLong 
	@Field(12) 
	public buffer modtime_size(long modtime_size) {
		this.io.setCLongField(this, 12, modtime_size);
		return this;
	}
	/// The value of text->modiff at the last auto-save.
	@Field(13) 
	public int auto_save_modified() {
		return this.io.getIntField(this, 13);
	}
	/// The value of text->modiff at the last auto-save.
	@Field(13) 
	public buffer auto_save_modified(int auto_save_modified) {
		this.io.setIntField(this, 13, auto_save_modified);
		return this;
	}
	/**
	 * The value of text->modiff at the last display error.<br>
	 * Redisplay of this buffer is inhibited until it changes again.
	 */
	@Field(14) 
	public int display_error_modiff() {
		return this.io.getIntField(this, 14);
	}
	/**
	 * The value of text->modiff at the last display error.<br>
	 * Redisplay of this buffer is inhibited until it changes again.
	 */
	@Field(14) 
	public buffer display_error_modiff(int display_error_modiff) {
		this.io.setIntField(this, 14, display_error_modiff);
		return this;
	}
	/**
	 * The time at which we detected a failure to auto-save,<br>
	 * Or 0 if we didn't have a failure.<br>
	 * C type : time_t
	 */
	@CLong 
	@Field(15) 
	public long auto_save_failure_time() {
		return this.io.getCLongField(this, 15);
	}
	/**
	 * The time at which we detected a failure to auto-save,<br>
	 * Or 0 if we didn't have a failure.<br>
	 * C type : time_t
	 */
	@CLong 
	@Field(15) 
	public buffer auto_save_failure_time(long auto_save_failure_time) {
		this.io.setCLongField(this, 15, auto_save_failure_time);
		return this;
	}
	/// Set nonzero whenever the narrowing is changed in this buffer.
	@Field(17) 
	public int clip_changed() {
		return this.io.getIntField(this, 17);
	}
	/// Set nonzero whenever the narrowing is changed in this buffer.
	@Field(17) 
	public buffer clip_changed(int clip_changed) {
		this.io.setIntField(this, 17, clip_changed);
		return this;
	}
	/**
	 * If the long line scan cache is enabled (i.e. the buffer-local<br>
	 * variable cache-long-line-scans is non-nil), newline_cache<br>
	 * points to the newline cache, and width_run_cache points to the<br>
	 * width run cache.<br>
	 * The newline cache records which stretches of the buffer are<br>
	 * known *not* to contain newlines, so that they can be skipped<br>
	 * quickly when we search for newlines.<br>
	 * The width run cache records which stretches of the buffer are<br>
	 * known to contain characters whose widths are all the same.  If<br>
	 * the width run cache maps a character to a value > 0, that value is<br>
	 * the character's width; if it maps a character to zero, we don't<br>
	 * know what its width is.  This allows compute_motion to process<br>
	 * such regions very quickly, using algebra instead of inspecting<br>
	 * each character.   See also width_table, below.<br>
	 * C type : region_cache*
	 */
	@Field(18) 
	public Pointer<region_cache > newline_cache() {
		return this.io.getPointerField(this, 18);
	}
	/**
	 * If the long line scan cache is enabled (i.e. the buffer-local<br>
	 * variable cache-long-line-scans is non-nil), newline_cache<br>
	 * points to the newline cache, and width_run_cache points to the<br>
	 * width run cache.<br>
	 * The newline cache records which stretches of the buffer are<br>
	 * known *not* to contain newlines, so that they can be skipped<br>
	 * quickly when we search for newlines.<br>
	 * The width run cache records which stretches of the buffer are<br>
	 * known to contain characters whose widths are all the same.  If<br>
	 * the width run cache maps a character to a value > 0, that value is<br>
	 * the character's width; if it maps a character to zero, we don't<br>
	 * know what its width is.  This allows compute_motion to process<br>
	 * such regions very quickly, using algebra instead of inspecting<br>
	 * each character.   See also width_table, below.<br>
	 * C type : region_cache*
	 */
	@Field(18) 
	public buffer newline_cache(Pointer<region_cache > newline_cache) {
		this.io.setPointerField(this, 18, newline_cache);
		return this;
	}
	/// C type : region_cache*
	@Field(19) 
	public Pointer<region_cache > width_run_cache() {
		return this.io.getPointerField(this, 19);
	}
	/// C type : region_cache*
	@Field(19) 
	public buffer width_run_cache(Pointer<region_cache > width_run_cache) {
		this.io.setPointerField(this, 19, width_run_cache);
		return this;
	}
	/**
	 * Non-zero means don't use redisplay optimizations for<br>
	 * displaying this buffer.
	 */
	@Field(20) 
	@Bits(1) 
	public int prevent_redisplay_optimizations_p() {
		return this.io.getIntField(this, 20);
	}
	/**
	 * Non-zero means don't use redisplay optimizations for<br>
	 * displaying this buffer.
	 */
	@Field(20) 
	@Bits(1) 
	public buffer prevent_redisplay_optimizations_p(int prevent_redisplay_optimizations_p) {
		this.io.setIntField(this, 20, prevent_redisplay_optimizations_p);
		return this;
	}
	/**
	 * List of overlays that end at or before the current center,<br>
	 * in order of end-position.<br>
	 * C type : Lisp_Overlay*
	 */
	@Field(21) 
	public Pointer<Lisp_Overlay > overlays_before() {
		return this.io.getPointerField(this, 21);
	}
	/**
	 * List of overlays that end at or before the current center,<br>
	 * in order of end-position.<br>
	 * C type : Lisp_Overlay*
	 */
	@Field(21) 
	public buffer overlays_before(Pointer<Lisp_Overlay > overlays_before) {
		this.io.setPointerField(this, 21, overlays_before);
		return this;
	}
	/**
	 * List of overlays that end after  the current center,<br>
	 * in order of start-position.<br>
	 * C type : Lisp_Overlay*
	 */
	@Field(22) 
	public Pointer<Lisp_Overlay > overlays_after() {
		return this.io.getPointerField(this, 22);
	}
	/**
	 * List of overlays that end after  the current center,<br>
	 * in order of start-position.<br>
	 * C type : Lisp_Overlay*
	 */
	@Field(22) 
	public buffer overlays_after(Pointer<Lisp_Overlay > overlays_after) {
		this.io.setPointerField(this, 22, overlays_after);
		return this;
	}
}
