package emacs.w32;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Pointer;
import org.bridj.ann.Array;
import org.bridj.ann.Library;
import org.bridj.ann.Runtime;
import org.bridj.util.DefaultParameterizedType;
/**
 * Wrapper for library <b>w32</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("w32") 
@Runtime(CRuntime.class) 
public class W32Library {
	static {
		BridJ.register();
	}
	public static final int STATUS_READ_ERROR = (int)-1;
	public static final int STATUS_READ_READY = (int)0;
	public static final int STATUS_READ_IN_PROGRESS = (int)1;
	public static final int STATUS_READ_FAILED = (int)2;
	public static final int STATUS_READ_SUCCEEDED = (int)3;
	public static final int STATUS_READ_ACKNOWLEDGED = (int)4;
	/// <i>native declaration : w32.h</i>
	public static final int FILE_BINARY = (int)16;
	/// <i>native declaration : w32.h</i>
	public static final int FILE_LISTEN = (int)4;
	/// <i>native declaration : w32.h</i>
	public static final int MAX_CHILDREN = (int)64 / 2;
	/// <i>native declaration : w32.h</i>
	public static final int FILE_WRITE = (int)2;
	/// <i>native declaration : w32.h</i>
	public static final int FD_SETSIZE = (int)64;
	/// <i>native declaration : w32.h</i>
	public static final int FILE_PIPE = (int)256;
	/// <i>native declaration : w32.h</i>
	public static final int FILE_READ = (int)1;
	/// <i>native declaration : w32.h</i>
	public static final int FILE_AT_EOF = (int)64;
	/// <i>native declaration : w32.h</i>
	public static final int MAXDESC = (int)64;
	/// <i>native declaration : w32.h</i>
	public static final int FILE_SERIAL = (int)2048;
	/// <i>native declaration : w32.h</i>
	public static final int FILE_NDELAY = (int)1024;
	/// <i>native declaration : w32.h</i>
	public static final int FILE_LAST_CR = (int)32;
	/// <i>native declaration : w32.h</i>
	public static final int FILE_SOCKET = (int)512;
	/// <i>native declaration : w32.h</i>
	public static final int FILE_SEND_SIGCHLD = (int)128;
	/**
	 * Original signature : <code>child_process* new_child()</code><br>
	 * <i>native declaration : w32.h:37</i>
	 */
	public static native Pointer<child_process > new_child();
	/**
	 * Original signature : <code>void delete_child(child_process*)</code><br>
	 * <i>native declaration : w32.h:39</i>
	 */
	public static native void delete_child(Pointer<child_process > cp);
	/**
	 * Equivalent of strerror for W32 error codes.<br>
	 * Original signature : <code>char* w32_strerror(int)</code><br>
	 * <i>native declaration : w32.h:44</i>
	 */
	public static native Pointer<Byte > w32_strerror(int error_no);
	/**
	 * Validate a pointer.<br>
	 * Original signature : <code>int w32_valid_pointer_p(void*, int)</code><br>
	 * <i>native declaration : w32.h:49</i>
	 */
	public static native int w32_valid_pointer_p(Pointer<? > voidPtr1, int int1);
	/**
	 * Get long (aka "true") form of file name, if it exists.<br>
	 * Original signature : <code>BOOL w32_get_long_filename(char*, char*, int)</code><br>
	 * <i>native declaration : w32.h:54</i>
	 */
	public static native int w32_get_long_filename(Pointer<Byte > name, Pointer<Byte > buf, int size);
	/**
	 * Prepare our standard handles for proper inheritance by child processes.<br>
	 * Original signature : <code>void prepare_standard_handles(int, int, int, HANDLE[4])</code><br>
	 * <i>native declaration : w32.h:59</i>
	 */
	public static native void prepare_standard_handles(int in, int out, int err, Pointer<W32Library.HANDLE > handles);
	/**
	 * Reset our standard handles to their original state.<br>
	 * Original signature : <code>void reset_standard_handles(int, int, int, HANDLE[4])</code><br>
	 * <i>native declaration : w32.h:64</i>
	 */
	public static native void reset_standard_handles(int in, int out, int err, Pointer<W32Library.HANDLE > handles);
	/**
	 * Return the string resource associated with KEY of type TYPE.<br>
	 * Original signature : <code>LPBYTE w32_get_resource(char*, LPDWORD)</code><br>
	 * <i>native declaration : w32.h:69</i>
	 */
	public static native W32Library.LPBYTE w32_get_resource(Pointer<Byte > key, W32Library.LPDWORD type);
	/**
	 * Original signature : <code>void init_ntproc()</code><br>
	 * <i>native declaration : w32.h:71</i>
	 */
	public static native void init_ntproc();
	/**
	 * Original signature : <code>void term_ntproc()</code><br>
	 * <i>native declaration : w32.h:73</i>
	 */
	public static native void term_ntproc();
	/**
	 * Original signature : <code>void globals_of_w32()</code><br>
	 * <i>native declaration : w32.h:75</i>
	 */
	public static native void globals_of_w32();
	/**
	 * Original signature : <code>void syms_of_w32term()</code><br>
	 * <i>native declaration : w32.h:77</i>
	 */
	public static native void syms_of_w32term();
	/**
	 * Original signature : <code>void syms_of_w32fns()</code><br>
	 * <i>native declaration : w32.h:79</i>
	 */
	public static native void syms_of_w32fns();
	/**
	 * Original signature : <code>void globals_of_w32fns()</code><br>
	 * <i>native declaration : w32.h:81</i>
	 */
	public static native void globals_of_w32fns();
	/**
	 * Original signature : <code>void syms_of_w32select()</code><br>
	 * <i>native declaration : w32.h:83</i>
	 */
	public static native void syms_of_w32select();
	/**
	 * Original signature : <code>void globals_of_w32select()</code><br>
	 * <i>native declaration : w32.h:85</i>
	 */
	public static native void globals_of_w32select();
	/**
	 * Original signature : <code>void term_w32select()</code><br>
	 * <i>native declaration : w32.h:87</i>
	 */
	public static native void term_w32select();
	/**
	 * Original signature : <code>void syms_of_w32menu()</code><br>
	 * <i>native declaration : w32.h:89</i>
	 */
	public static native void syms_of_w32menu();
	/**
	 * Original signature : <code>void globals_of_w32menu()</code><br>
	 * <i>native declaration : w32.h:91</i>
	 */
	public static native void globals_of_w32menu();
	/**
	 * Original signature : <code>void syms_of_fontset()</code><br>
	 * <i>native declaration : w32.h:93</i>
	 */
	public static native void syms_of_fontset();
	/**
	 * Original signature : <code>void syms_of_w32font()</code><br>
	 * <i>native declaration : w32.h:95</i>
	 */
	public static native void syms_of_w32font();
	/**
	 * Original signature : <code>int _sys_read_ahead(int)</code><br>
	 * <i>native declaration : w32.h:97</i>
	 */
	public static native int _sys_read_ahead(int fd);
	/**
	 * Original signature : <code>int _sys_wait_accept(int)</code><br>
	 * <i>native declaration : w32.h:99</i>
	 */
	public static native int _sys_wait_accept(int fd);
	/**
	 * Original signature : <code>HMODULE w32_delayed_load(Lisp_Object, Lisp_Object)</code><br>
	 * <i>native declaration : w32.h:103</i>
	 */
	public static native W32Library.HMODULE w32_delayed_load(W32Library.Lisp_Object Lisp_Object1, W32Library.Lisp_Object Lisp_Object2);
	/// C type : extern filedesc[64]
	@Array({64}) 
	public Pointer<filedesc > fd_info() {
		try {
			return (Pointer<filedesc >)BridJ.getNativeLibrary("w32").getSymbolPointer("fd_info").as(DefaultParameterizedType.paramType(Pointer.class, filedesc.class)).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/// Undefined type
	/// Undefined type
	public static interface LPBYTE {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface HMODULE {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface PROCESS_INFORMATION {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface OVERLAPPED {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface HWND {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface HANDLE {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface Lisp_Object {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LPDWORD {
		
	};
}
