package emacs.indent;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Runtime;
/**
 * Wrapper for library <b>indent</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("indent") 
@Runtime(CRuntime.class) 
public class IndentLibrary {
	static {
		BridJ.register();
	}
	/**
	 * Original signature : <code>position* compute_motion(EMACS_INT, EMACS_INT, EMACS_INT, int, EMACS_INT, EMACS_INT, EMACS_INT, EMACS_INT, EMACS_INT, EMACS_INT, window*)</code><br>
	 * <i>native declaration : indent.h:15</i>
	 */
	public static native Pointer<position > compute_motion(IndentLibrary.EMACS_INT from, IndentLibrary.EMACS_INT fromvpos, IndentLibrary.EMACS_INT fromhpos, int did_motion, IndentLibrary.EMACS_INT to, IndentLibrary.EMACS_INT tovpos, IndentLibrary.EMACS_INT tohpos, IndentLibrary.EMACS_INT width, IndentLibrary.EMACS_INT hscroll, IndentLibrary.EMACS_INT tab_offset, Pointer<IndentLibrary.window > windowPtr1);
	/**
	 * Original signature : <code>position* vmotion(EMACS_INT, EMACS_INT, window*)</code><br>
	 * <i>native declaration : indent.h:17</i>
	 */
	public static native Pointer<position > vmotion(IndentLibrary.EMACS_INT from, IndentLibrary.EMACS_INT vtarget, Pointer<IndentLibrary.window > windowPtr1);
	/**
	 * Original signature : <code>EMACS_INT skip_invisible(EMACS_INT, EMACS_INT*, EMACS_INT, Lisp_Object)</code><br>
	 * <i>native declaration : indent.h:19</i>
	 */
	public static native IndentLibrary.EMACS_INT skip_invisible(IndentLibrary.EMACS_INT pos, Pointer<IndentLibrary.EMACS_INT > next_boundary_p, IndentLibrary.EMACS_INT to, IndentLibrary.Lisp_Object window);
	/**
	 * Return true if the display table DISPTAB specifies the same widths<br>
	 * for characters as WIDTHTAB.  We use this to decide when to<br>
	 * invalidate the buffer's column_cache.<br>
	 * Original signature : <code>int disptab_matches_widthtab(Lisp_Char_Table*, Lisp_Vector*)</code><br>
	 * <i>native declaration : indent.h:28</i>
	 */
	public static native int disptab_matches_widthtab(Pointer<IndentLibrary.Lisp_Char_Table > disptab, Pointer<IndentLibrary.Lisp_Vector > widthtab);
	/**
	 * Recompute BUF's width table, using the display table DISPTAB.<br>
	 * Original signature : <code>void recompute_width_table(buffer*, Lisp_Char_Table*)</code><br>
	 * <i>native declaration : indent.h:33</i>
	 */
	public static native void recompute_width_table(Pointer<IndentLibrary.buffer > buf, Pointer<IndentLibrary.Lisp_Char_Table > disptab);
	/// Undefined type
	/// Undefined type
	public static interface buffer {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface Lisp_Vector {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface window {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface Lisp_Char_Table {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface Lisp_Object {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface EMACS_INT {
		
	};
}
