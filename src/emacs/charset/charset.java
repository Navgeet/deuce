package emacs.charset;
import emacs.charset.CharsetLibrary.charset_method;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Array;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
import org.bridj.ann.Ptr;
/**
 * <i>native declaration : charset.h:204</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("charset") 
public class charset extends StructObject {
	public charset() {
		super();
	}
	/// Index to charset_table.
	@Field(0) 
	public int id() {
		return this.io.getIntField(this, 0);
	}
	/// Index to charset_table.
	@Field(0) 
	public charset id(int id) {
		this.io.setIntField(this, 0, id);
		return this;
	}
	/// Index to Vcharset_hash_table.
	@Ptr 
	@Field(1) 
	public long hash_index() {
		return this.io.getSizeTField(this, 1);
	}
	/// Index to Vcharset_hash_table.
	@Ptr 
	@Field(1) 
	public charset hash_index(long hash_index) {
		this.io.setSizeTField(this, 1, hash_index);
		return this;
	}
	/// Dimension of the charset: 1, 2, 3, or 4.
	@Field(2) 
	public int dimension() {
		return this.io.getIntField(this, 2);
	}
	/// Dimension of the charset: 1, 2, 3, or 4.
	@Field(2) 
	public charset dimension(int dimension) {
		this.io.setIntField(this, 2, dimension);
		return this;
	}
	/**
	 * Byte code range of each dimension.  <code_space>[4N] is a minimum<br>
	 * byte code of the (N+1)th dimension, <code_space>[4N+1] is a<br>
	 * maximum byte code of the (N+1)th dimension, <code_space>[4N+2] is<br>
	 * (<code_space>[4N+1] - <code_space>[4N] + 1), <code_space>[4N+3]<br>
	 * is the number of characters contained in the first through (N+1)th<br>
	 * dimensions, except that there is no <code_space>[15].<br>
	 * We get `char-index' of a `code-point' from this<br>
	 * information.<br>
	 * C type : int[15]
	 */
	@Array({15}) 
	@Field(3) 
	public Pointer<Integer > code_space() {
		return this.io.getPointerField(this, 3);
	}
	/**
	 * If B is a byte of Nth dimension of a code-point, the (N-1)th bit<br>
	 * of code_space_mask[B] is set.  This array is used to quickly<br>
	 * check if a code-point is in a valid range.<br>
	 * C type : unsigned char*
	 */
	@Field(4) 
	public Pointer<Byte > code_space_mask() {
		return this.io.getPointerField(this, 4);
	}
	/**
	 * If B is a byte of Nth dimension of a code-point, the (N-1)th bit<br>
	 * of code_space_mask[B] is set.  This array is used to quickly<br>
	 * check if a code-point is in a valid range.<br>
	 * C type : unsigned char*
	 */
	@Field(4) 
	public charset code_space_mask(Pointer<Byte > code_space_mask) {
		this.io.setPointerField(this, 4, code_space_mask);
		return this;
	}
	/// 1 if there's no gap in code-points.
	@Field(5) 
	public int code_linear_p() {
		return this.io.getIntField(this, 5);
	}
	/// 1 if there's no gap in code-points.
	@Field(5) 
	public charset code_linear_p(int code_linear_p) {
		this.io.setIntField(this, 5, code_linear_p);
		return this;
	}
	/**
	 * If the charset is treated as 94-chars in ISO-2022, the value is 0.<br>
	 * If the charset is treated as 96-chars in ISO-2022, the value is 1.
	 */
	@Field(6) 
	public int iso_chars_96() {
		return this.io.getIntField(this, 6);
	}
	/**
	 * If the charset is treated as 94-chars in ISO-2022, the value is 0.<br>
	 * If the charset is treated as 96-chars in ISO-2022, the value is 1.
	 */
	@Field(6) 
	public charset iso_chars_96(int iso_chars_96) {
		this.io.setIntField(this, 6, iso_chars_96);
		return this;
	}
	/**
	 * ISO final byte of the charset: 48..127.  It may be -1 if the<br>
	 * charset doesn't conform to ISO-2022.
	 */
	@Field(7) 
	public int iso_final() {
		return this.io.getIntField(this, 7);
	}
	/**
	 * ISO final byte of the charset: 48..127.  It may be -1 if the<br>
	 * charset doesn't conform to ISO-2022.
	 */
	@Field(7) 
	public charset iso_final(int iso_final) {
		this.io.setIntField(this, 7, iso_final);
		return this;
	}
	/// ISO revision number of the charset.
	@Field(8) 
	public int iso_revision() {
		return this.io.getIntField(this, 8);
	}
	/// ISO revision number of the charset.
	@Field(8) 
	public charset iso_revision(int iso_revision) {
		this.io.setIntField(this, 8, iso_revision);
		return this;
	}
	/**
	 * If the charset is identical to what supported by Emacs 21 and the<br>
	 * priors, the identification number of the charset used in those<br>
	 * version.  Otherwise, -1.
	 */
	@Field(9) 
	public int emacs_mule_id() {
		return this.io.getIntField(this, 9);
	}
	/**
	 * If the charset is identical to what supported by Emacs 21 and the<br>
	 * priors, the identification number of the charset used in those<br>
	 * version.  Otherwise, -1.
	 */
	@Field(9) 
	public charset emacs_mule_id(int emacs_mule_id) {
		this.io.setIntField(this, 9, emacs_mule_id);
		return this;
	}
	/// Nonzero if the charset is compatible with ASCII.
	@Field(10) 
	public int ascii_compatible_p() {
		return this.io.getIntField(this, 10);
	}
	/// Nonzero if the charset is compatible with ASCII.
	@Field(10) 
	public charset ascii_compatible_p(int ascii_compatible_p) {
		this.io.setIntField(this, 10, ascii_compatible_p);
		return this;
	}
	/// Nonzero if the charset is supplementary.
	@Field(11) 
	public int supplementary_p() {
		return this.io.getIntField(this, 11);
	}
	/// Nonzero if the charset is supplementary.
	@Field(11) 
	public charset supplementary_p(int supplementary_p) {
		this.io.setIntField(this, 11, supplementary_p);
		return this;
	}
	/// Nonzero if all the code points are representable by Lisp_Int.
	@Field(12) 
	public int compact_codes_p() {
		return this.io.getIntField(this, 12);
	}
	/// Nonzero if all the code points are representable by Lisp_Int.
	@Field(12) 
	public charset compact_codes_p(int compact_codes_p) {
		this.io.setIntField(this, 12, compact_codes_p);
		return this;
	}
	/**
	 * The method for encoding/decoding characters of the charset.<br>
	 * C type : charset_method
	 */
	@Field(13) 
	public IntValuedEnum<charset_method > method() {
		return this.io.getEnumField(this, 13);
	}
	/**
	 * The method for encoding/decoding characters of the charset.<br>
	 * C type : charset_method
	 */
	@Field(13) 
	public charset method(IntValuedEnum<charset_method > method) {
		this.io.setEnumField(this, 13, method);
		return this;
	}
	/// Minimum and Maximum code points of the charset.
	@Field(14) 
	public int min_code() {
		return this.io.getIntField(this, 14);
	}
	/// Minimum and Maximum code points of the charset.
	@Field(14) 
	public charset min_code(int min_code) {
		this.io.setIntField(this, 14, min_code);
		return this;
	}
	/// Minimum and Maximum code points of the charset.
	@Field(15) 
	public int max_code() {
		return this.io.getIntField(this, 15);
	}
	/// Minimum and Maximum code points of the charset.
	@Field(15) 
	public charset max_code(int max_code) {
		this.io.setIntField(this, 15, max_code);
		return this;
	}
	/**
	 * Offset value used by macros CODE_POINT_TO_INDEX and<br>
	 * INDEX_TO_CODE_POINT. .
	 */
	@Field(16) 
	public int char_index_offset() {
		return this.io.getIntField(this, 16);
	}
	/**
	 * Offset value used by macros CODE_POINT_TO_INDEX and<br>
	 * INDEX_TO_CODE_POINT. .
	 */
	@Field(16) 
	public charset char_index_offset(int char_index_offset) {
		this.io.setIntField(this, 16, char_index_offset);
		return this;
	}
	/**
	 * Minimum and Maximum character codes of the charset.  If the<br>
	 * charset is compatible with ASCII, min_char is a minimum non-ASCII<br>
	 * character of the charset.  If the method of charset is<br>
	 * CHARSET_METHOD_OFFSET, even if the charset is unified, min_char<br>
	 * and max_char doesn't change.
	 */
	@Field(17) 
	public int min_char() {
		return this.io.getIntField(this, 17);
	}
	/**
	 * Minimum and Maximum character codes of the charset.  If the<br>
	 * charset is compatible with ASCII, min_char is a minimum non-ASCII<br>
	 * character of the charset.  If the method of charset is<br>
	 * CHARSET_METHOD_OFFSET, even if the charset is unified, min_char<br>
	 * and max_char doesn't change.
	 */
	@Field(17) 
	public charset min_char(int min_char) {
		this.io.setIntField(this, 17, min_char);
		return this;
	}
	/**
	 * Minimum and Maximum character codes of the charset.  If the<br>
	 * charset is compatible with ASCII, min_char is a minimum non-ASCII<br>
	 * character of the charset.  If the method of charset is<br>
	 * CHARSET_METHOD_OFFSET, even if the charset is unified, min_char<br>
	 * and max_char doesn't change.
	 */
	@Field(18) 
	public int max_char() {
		return this.io.getIntField(this, 18);
	}
	/**
	 * Minimum and Maximum character codes of the charset.  If the<br>
	 * charset is compatible with ASCII, min_char is a minimum non-ASCII<br>
	 * character of the charset.  If the method of charset is<br>
	 * CHARSET_METHOD_OFFSET, even if the charset is unified, min_char<br>
	 * and max_char doesn't change.
	 */
	@Field(18) 
	public charset max_char(int max_char) {
		this.io.setIntField(this, 18, max_char);
		return this;
	}
	/**
	 * The code returned by ENCODE_CHAR if a character is not encodable<br>
	 * by the charset.
	 */
	@Field(19) 
	public int invalid_code() {
		return this.io.getIntField(this, 19);
	}
	/**
	 * The code returned by ENCODE_CHAR if a character is not encodable<br>
	 * by the charset.
	 */
	@Field(19) 
	public charset invalid_code(int invalid_code) {
		this.io.setIntField(this, 19, invalid_code);
		return this;
	}
	/**
	 * If the method of the charset is CHARSET_METHOD_MAP, this is a<br>
	 * table of bits used to quickly and roughly guess if a character<br>
	 * belongs to the charset.<br>
	 * The first 64 elements are 512 bits for characters less than<br>
	 * 0x10000.  Each bit corresponds to 128-character block.  The last<br>
	 * 126 elements are 1008 bits for the greater characters<br>
	 * (0x10000..0x3FFFFF).  Each bit corresponds to 4096-character<br>
	 * block.<br>
	 * If a bit is 1, at least one character in the corresponding block is<br>
	 * in this charset.<br>
	 * C type : unsigned char[190]
	 */
	@Array({190}) 
	@Field(20) 
	public Pointer<Byte > fast_map() {
		return this.io.getPointerField(this, 20);
	}
	/**
	 * Offset value to calculate a character code from code-point, and<br>
	 * visa versa.
	 */
	@Field(21) 
	public int code_offset() {
		return this.io.getIntField(this, 21);
	}
	/**
	 * Offset value to calculate a character code from code-point, and<br>
	 * visa versa.
	 */
	@Field(21) 
	public charset code_offset(int code_offset) {
		this.io.setIntField(this, 21, code_offset);
		return this;
	}
	@Field(22) 
	public int unified_p() {
		return this.io.getIntField(this, 22);
	}
	@Field(22) 
	public charset unified_p(int unified_p) {
		this.io.setIntField(this, 22, unified_p);
		return this;
	}
}
