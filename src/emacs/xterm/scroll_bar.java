package emacs.xterm;
import emacs.xterm.XtermLibrary.Lisp_Vector;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Bits;
import org.bridj.ann.CLong;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
/**
 * <i>native declaration : xterm.h:3019</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("xterm") 
public class scroll_bar extends StructObject {
	public scroll_bar() {
		super();
	}
	/// C type : Lisp_Vector*
	@Field(1) 
	public Pointer<Lisp_Vector > next_from_Lisp_Vector_struct() {
		return this.io.getPointerField(this, 1);
	}
	/// C type : Lisp_Vector*
	@Field(1) 
	public scroll_bar next_from_Lisp_Vector_struct(Pointer<Lisp_Vector > next_from_Lisp_Vector_struct) {
		this.io.setPointerField(this, 1, next_from_Lisp_Vector_struct);
		return this;
	}
	/**
	 * The X window representing this scroll bar.<br>
	 * C type : Window
	 */
	@CLong 
	@Field(5) 
	public long x_window() {
		return this.io.getCLongField(this, 5);
	}
	/**
	 * The X window representing this scroll bar.<br>
	 * C type : Window
	 */
	@CLong 
	@Field(5) 
	public scroll_bar x_window(long x_window) {
		this.io.setCLongField(this, 5, x_window);
		return this;
	}
	/**
	 * The position and size of the scroll bar in pixels, relative to the<br>
	 * frame.
	 */
	@Field(6) 
	public int top() {
		return this.io.getIntField(this, 6);
	}
	/**
	 * The position and size of the scroll bar in pixels, relative to the<br>
	 * frame.
	 */
	@Field(6) 
	public scroll_bar top(int top) {
		this.io.setIntField(this, 6, top);
		return this;
	}
	/**
	 * The position and size of the scroll bar in pixels, relative to the<br>
	 * frame.
	 */
	@Field(7) 
	public int left() {
		return this.io.getIntField(this, 7);
	}
	/**
	 * The position and size of the scroll bar in pixels, relative to the<br>
	 * frame.
	 */
	@Field(7) 
	public scroll_bar left(int left) {
		this.io.setIntField(this, 7, left);
		return this;
	}
	/**
	 * The position and size of the scroll bar in pixels, relative to the<br>
	 * frame.
	 */
	@Field(8) 
	public int width() {
		return this.io.getIntField(this, 8);
	}
	/**
	 * The position and size of the scroll bar in pixels, relative to the<br>
	 * frame.
	 */
	@Field(8) 
	public scroll_bar width(int width) {
		this.io.setIntField(this, 8, width);
		return this;
	}
	/**
	 * The position and size of the scroll bar in pixels, relative to the<br>
	 * frame.
	 */
	@Field(9) 
	public int height() {
		return this.io.getIntField(this, 9);
	}
	/**
	 * The position and size of the scroll bar in pixels, relative to the<br>
	 * frame.
	 */
	@Field(9) 
	public scroll_bar height(int height) {
		this.io.setIntField(this, 9, height);
		return this;
	}
	/**
	 * The starting and ending positions of the handle, relative to the<br>
	 * handle area (i.e. zero is the top position, not<br>
	 * SCROLL_BAR_TOP_BORDER).  If they're equal, that means the handle<br>
	 * hasn't been drawn yet.<br>
	 * These are not actually the locations where the beginning and end<br>
	 * are drawn; in order to keep handles from becoming invisible when<br>
	 * editing large files, we establish a minimum height by always<br>
	 * drawing handle bottoms VERTICAL_SCROLL_BAR_MIN_HANDLE pixels below<br>
	 * where they would be normally; the bottom and top are in a<br>
	 * different co-ordinate system.
	 */
	@Field(10) 
	public int start() {
		return this.io.getIntField(this, 10);
	}
	/**
	 * The starting and ending positions of the handle, relative to the<br>
	 * handle area (i.e. zero is the top position, not<br>
	 * SCROLL_BAR_TOP_BORDER).  If they're equal, that means the handle<br>
	 * hasn't been drawn yet.<br>
	 * These are not actually the locations where the beginning and end<br>
	 * are drawn; in order to keep handles from becoming invisible when<br>
	 * editing large files, we establish a minimum height by always<br>
	 * drawing handle bottoms VERTICAL_SCROLL_BAR_MIN_HANDLE pixels below<br>
	 * where they would be normally; the bottom and top are in a<br>
	 * different co-ordinate system.
	 */
	@Field(10) 
	public scroll_bar start(int start) {
		this.io.setIntField(this, 10, start);
		return this;
	}
	/**
	 * The starting and ending positions of the handle, relative to the<br>
	 * handle area (i.e. zero is the top position, not<br>
	 * SCROLL_BAR_TOP_BORDER).  If they're equal, that means the handle<br>
	 * hasn't been drawn yet.<br>
	 * These are not actually the locations where the beginning and end<br>
	 * are drawn; in order to keep handles from becoming invisible when<br>
	 * editing large files, we establish a minimum height by always<br>
	 * drawing handle bottoms VERTICAL_SCROLL_BAR_MIN_HANDLE pixels below<br>
	 * where they would be normally; the bottom and top are in a<br>
	 * different co-ordinate system.
	 */
	@Field(11) 
	public int end() {
		return this.io.getIntField(this, 11);
	}
	/**
	 * The starting and ending positions of the handle, relative to the<br>
	 * handle area (i.e. zero is the top position, not<br>
	 * SCROLL_BAR_TOP_BORDER).  If they're equal, that means the handle<br>
	 * hasn't been drawn yet.<br>
	 * These are not actually the locations where the beginning and end<br>
	 * are drawn; in order to keep handles from becoming invisible when<br>
	 * editing large files, we establish a minimum height by always<br>
	 * drawing handle bottoms VERTICAL_SCROLL_BAR_MIN_HANDLE pixels below<br>
	 * where they would be normally; the bottom and top are in a<br>
	 * different co-ordinate system.
	 */
	@Field(11) 
	public scroll_bar end(int end) {
		this.io.setIntField(this, 11, end);
		return this;
	}
	/**
	 * 1 if the background of the fringe that is adjacent to a scroll<br>
	 * bar is extended to the gap between the fringe and the bar.
	 */
	@Field(13) 
	@Bits(1) 
	public int fringe_extended_p() {
		return this.io.getIntField(this, 13);
	}
	/**
	 * 1 if the background of the fringe that is adjacent to a scroll<br>
	 * bar is extended to the gap between the fringe and the bar.
	 */
	@Field(13) 
	@Bits(1) 
	public scroll_bar fringe_extended_p(int fringe_extended_p) {
		this.io.setIntField(this, 13, fringe_extended_p);
		return this;
	}
}
