package emacs.xterm;
import emacs.xterm.XtermLibrary.GC;
import emacs.xterm.XtermLibrary.XEvent;
import emacs.xterm.XtermLibrary.font;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Bits;
import org.bridj.ann.CLong;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
import org.bridj.ann.Ptr;
/**
 * <i>native declaration : xterm.h:2936</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("xterm") 
public class x_output extends StructObject {
	public x_output() {
		super();
	}
	/**
	 * Height of menu bar widget, in pixels.<br>
	 * Zero if not using the X toolkit.<br>
	 * When using the toolkit, this value is not meaningful<br>
	 * if the menubar is turned off.
	 */
	@Field(0) 
	public int menubar_height() {
		return this.io.getIntField(this, 0);
	}
	/**
	 * Height of menu bar widget, in pixels.<br>
	 * Zero if not using the X toolkit.<br>
	 * When using the toolkit, this value is not meaningful<br>
	 * if the menubar is turned off.
	 */
	@Field(0) 
	public x_output menubar_height(int menubar_height) {
		this.io.setIntField(this, 0, menubar_height);
		return this;
	}
	/**
	 * Height of tool bar widget, in pixels.  top_height is used if tool bar<br>
	 * at top, bottom_height if tool bar is at the bottom.<br>
	 * Zero if not using an external tool bar or if tool bar is vertical.
	 */
	@Field(1) 
	public int toolbar_top_height() {
		return this.io.getIntField(this, 1);
	}
	/**
	 * Height of tool bar widget, in pixels.  top_height is used if tool bar<br>
	 * at top, bottom_height if tool bar is at the bottom.<br>
	 * Zero if not using an external tool bar or if tool bar is vertical.
	 */
	@Field(1) 
	public x_output toolbar_top_height(int toolbar_top_height) {
		this.io.setIntField(this, 1, toolbar_top_height);
		return this;
	}
	/**
	 * Height of tool bar widget, in pixels.  top_height is used if tool bar<br>
	 * at top, bottom_height if tool bar is at the bottom.<br>
	 * Zero if not using an external tool bar or if tool bar is vertical.
	 */
	@Field(2) 
	public int toolbar_bottom_height() {
		return this.io.getIntField(this, 2);
	}
	/**
	 * Height of tool bar widget, in pixels.  top_height is used if tool bar<br>
	 * at top, bottom_height if tool bar is at the bottom.<br>
	 * Zero if not using an external tool bar or if tool bar is vertical.
	 */
	@Field(2) 
	public x_output toolbar_bottom_height(int toolbar_bottom_height) {
		this.io.setIntField(this, 2, toolbar_bottom_height);
		return this;
	}
	/**
	 * Width of tool bar widget, in pixels.  left_width is used if tool bar<br>
	 * at left, right_width if tool bar is at the right.<br>
	 * Zero if not using an external tool bar or if tool bar is horizontal.
	 */
	@Field(3) 
	public int toolbar_left_width() {
		return this.io.getIntField(this, 3);
	}
	/**
	 * Width of tool bar widget, in pixels.  left_width is used if tool bar<br>
	 * at left, right_width if tool bar is at the right.<br>
	 * Zero if not using an external tool bar or if tool bar is horizontal.
	 */
	@Field(3) 
	public x_output toolbar_left_width(int toolbar_left_width) {
		this.io.setIntField(this, 3, toolbar_left_width);
		return this;
	}
	/**
	 * Width of tool bar widget, in pixels.  left_width is used if tool bar<br>
	 * at left, right_width if tool bar is at the right.<br>
	 * Zero if not using an external tool bar or if tool bar is horizontal.
	 */
	@Field(4) 
	public int toolbar_right_width() {
		return this.io.getIntField(this, 4);
	}
	/**
	 * Width of tool bar widget, in pixels.  left_width is used if tool bar<br>
	 * at left, right_width if tool bar is at the right.<br>
	 * Zero if not using an external tool bar or if tool bar is horizontal.
	 */
	@Field(4) 
	public x_output toolbar_right_width(int toolbar_right_width) {
		this.io.setIntField(this, 4, toolbar_right_width);
		return this;
	}
	/**
	 * The tiled border used when the mouse is out of the frame.<br>
	 * C type : Pixmap
	 */
	@CLong 
	@Field(5) 
	public long border_tile() {
		return this.io.getCLongField(this, 5);
	}
	/**
	 * The tiled border used when the mouse is out of the frame.<br>
	 * C type : Pixmap
	 */
	@CLong 
	@Field(5) 
	public x_output border_tile(long border_tile) {
		this.io.setCLongField(this, 5, border_tile);
		return this;
	}
	/**
	 * Here are the Graphics Contexts for the default font.<br>
	 * Normal video<br>
	 * C type : GC
	 */
	@Field(6) 
	public GC normal_gc() {
		return this.io.getTypedPointerField(this, 6);
	}
	/**
	 * Here are the Graphics Contexts for the default font.<br>
	 * Normal video<br>
	 * C type : GC
	 */
	@Field(6) 
	public x_output normal_gc(GC normal_gc) {
		this.io.setPointerField(this, 6, normal_gc);
		return this;
	}
	/**
	 * Reverse video<br>
	 * C type : GC
	 */
	@Field(7) 
	public GC reverse_gc() {
		return this.io.getTypedPointerField(this, 7);
	}
	/**
	 * Reverse video<br>
	 * C type : GC
	 */
	@Field(7) 
	public x_output reverse_gc(GC reverse_gc) {
		this.io.setPointerField(this, 7, reverse_gc);
		return this;
	}
	/**
	 * cursor drawing<br>
	 * C type : GC
	 */
	@Field(8) 
	public GC cursor_gc() {
		return this.io.getTypedPointerField(this, 8);
	}
	/**
	 * cursor drawing<br>
	 * C type : GC
	 */
	@Field(8) 
	public x_output cursor_gc(GC cursor_gc) {
		this.io.setPointerField(this, 8, cursor_gc);
		return this;
	}
	/**
	 * The X window used for this frame.<br>
	 * May be zero while the frame object is being created<br>
	 * and the X window has not yet been created.<br>
	 * C type : Window
	 */
	@CLong 
	@Field(9) 
	public long window_desc() {
		return this.io.getCLongField(this, 9);
	}
	/**
	 * The X window used for this frame.<br>
	 * May be zero while the frame object is being created<br>
	 * and the X window has not yet been created.<br>
	 * C type : Window
	 */
	@CLong 
	@Field(9) 
	public x_output window_desc(long window_desc) {
		this.io.setCLongField(this, 9, window_desc);
		return this;
	}
	/**
	 * The X window used for the bitmap icon;<br>
	 * or 0 if we don't have a bitmap icon.<br>
	 * C type : Window
	 */
	@CLong 
	@Field(10) 
	public long icon_desc() {
		return this.io.getCLongField(this, 10);
	}
	/**
	 * The X window used for the bitmap icon;<br>
	 * or 0 if we don't have a bitmap icon.<br>
	 * C type : Window
	 */
	@CLong 
	@Field(10) 
	public x_output icon_desc(long icon_desc) {
		this.io.setCLongField(this, 10, icon_desc);
		return this;
	}
	/**
	 * The X window that is the parent of this X window.<br>
	 * Usually this is a window that was made by the window manager,<br>
	 * but it can be the root window, and it can be explicitly specified<br>
	 * (see the explicit_parent field, below).<br>
	 * C type : Window
	 */
	@CLong 
	@Field(11) 
	public long parent_desc() {
		return this.io.getCLongField(this, 11);
	}
	/**
	 * The X window that is the parent of this X window.<br>
	 * Usually this is a window that was made by the window manager,<br>
	 * but it can be the root window, and it can be explicitly specified<br>
	 * (see the explicit_parent field, below).<br>
	 * C type : Window
	 */
	@CLong 
	@Field(11) 
	public x_output parent_desc(long parent_desc) {
		this.io.setCLongField(this, 11, parent_desc);
		return this;
	}
	/**
	 * If >=0, a bitmap index.  The indicated bitmap is used for the<br>
	 * icon.
	 */
	@Ptr 
	@Field(12) 
	public long icon_bitmap() {
		return this.io.getSizeTField(this, 12);
	}
	/**
	 * If >=0, a bitmap index.  The indicated bitmap is used for the<br>
	 * icon.
	 */
	@Ptr 
	@Field(12) 
	public x_output icon_bitmap(long icon_bitmap) {
		this.io.setSizeTField(this, 12, icon_bitmap);
		return this;
	}
	/**
	 * Default ASCII font of this frame.<br>
	 * C type : font*
	 */
	@Field(13) 
	public Pointer<font > font() {
		return this.io.getPointerField(this, 13);
	}
	/**
	 * Default ASCII font of this frame.<br>
	 * C type : font*
	 */
	@Field(13) 
	public x_output font(Pointer<font > font) {
		this.io.setPointerField(this, 13, font);
		return this;
	}
	/// The baseline offset of the default ASCII font.
	@Field(14) 
	public int baseline_offset() {
		return this.io.getIntField(this, 14);
	}
	/// The baseline offset of the default ASCII font.
	@Field(14) 
	public x_output baseline_offset(int baseline_offset) {
		this.io.setIntField(this, 14, baseline_offset);
		return this;
	}
	/**
	 * If a fontset is specified for this frame instead of font, this<br>
	 * value contains an ID of the fontset, else -1.
	 */
	@Field(15) 
	public int fontset() {
		return this.io.getIntField(this, 15);
	}
	/**
	 * If a fontset is specified for this frame instead of font, this<br>
	 * value contains an ID of the fontset, else -1.
	 */
	@Field(15) 
	public x_output fontset(int fontset) {
		this.io.setIntField(this, 15, fontset);
		return this;
	}
	@CLong 
	@Field(16) 
	public long cursor_pixel() {
		return this.io.getCLongField(this, 16);
	}
	@CLong 
	@Field(16) 
	public x_output cursor_pixel(long cursor_pixel) {
		this.io.setCLongField(this, 16, cursor_pixel);
		return this;
	}
	@CLong 
	@Field(17) 
	public long border_pixel() {
		return this.io.getCLongField(this, 17);
	}
	@CLong 
	@Field(17) 
	public x_output border_pixel(long border_pixel) {
		this.io.setCLongField(this, 17, border_pixel);
		return this;
	}
	@CLong 
	@Field(18) 
	public long mouse_pixel() {
		return this.io.getCLongField(this, 18);
	}
	@CLong 
	@Field(18) 
	public x_output mouse_pixel(long mouse_pixel) {
		this.io.setCLongField(this, 18, mouse_pixel);
		return this;
	}
	@CLong 
	@Field(19) 
	public long cursor_foreground_pixel() {
		return this.io.getCLongField(this, 19);
	}
	@CLong 
	@Field(19) 
	public x_output cursor_foreground_pixel(long cursor_foreground_pixel) {
		this.io.setCLongField(this, 19, cursor_foreground_pixel);
		return this;
	}
	/**
	 * Foreground color for scroll bars.  A value of -1 means use the<br>
	 * default (black for non-toolkit scroll bars).
	 */
	@CLong 
	@Field(20) 
	public long scroll_bar_foreground_pixel() {
		return this.io.getCLongField(this, 20);
	}
	/**
	 * Foreground color for scroll bars.  A value of -1 means use the<br>
	 * default (black for non-toolkit scroll bars).
	 */
	@CLong 
	@Field(20) 
	public x_output scroll_bar_foreground_pixel(long scroll_bar_foreground_pixel) {
		this.io.setCLongField(this, 20, scroll_bar_foreground_pixel);
		return this;
	}
	/**
	 * Background color for scroll bars.  A value of -1 means use the<br>
	 * default (background color of the frame for non-toolkit scroll<br>
	 * bars).
	 */
	@CLong 
	@Field(21) 
	public long scroll_bar_background_pixel() {
		return this.io.getCLongField(this, 21);
	}
	/**
	 * Background color for scroll bars.  A value of -1 means use the<br>
	 * default (background color of the frame for non-toolkit scroll<br>
	 * bars).
	 */
	@CLong 
	@Field(21) 
	public x_output scroll_bar_background_pixel(long scroll_bar_background_pixel) {
		this.io.setCLongField(this, 21, scroll_bar_background_pixel);
		return this;
	}
	/**
	 * Top and bottom shadow colors for 3d toolkit scrollbars.  -1 means<br>
	 * let the scroll compute them itself.
	 */
	@CLong 
	@Field(22) 
	public long scroll_bar_top_shadow_pixel() {
		return this.io.getCLongField(this, 22);
	}
	/**
	 * Top and bottom shadow colors for 3d toolkit scrollbars.  -1 means<br>
	 * let the scroll compute them itself.
	 */
	@CLong 
	@Field(22) 
	public x_output scroll_bar_top_shadow_pixel(long scroll_bar_top_shadow_pixel) {
		this.io.setCLongField(this, 22, scroll_bar_top_shadow_pixel);
		return this;
	}
	@CLong 
	@Field(23) 
	public long scroll_bar_bottom_shadow_pixel() {
		return this.io.getCLongField(this, 23);
	}
	@CLong 
	@Field(23) 
	public x_output scroll_bar_bottom_shadow_pixel(long scroll_bar_bottom_shadow_pixel) {
		this.io.setCLongField(this, 23, scroll_bar_bottom_shadow_pixel);
		return this;
	}
	/**
	 * Descriptor for the cursor in use for this window.<br>
	 * C type : Cursor
	 */
	@CLong 
	@Field(24) 
	public long text_cursor() {
		return this.io.getCLongField(this, 24);
	}
	/**
	 * Descriptor for the cursor in use for this window.<br>
	 * C type : Cursor
	 */
	@CLong 
	@Field(24) 
	public x_output text_cursor(long text_cursor) {
		this.io.setCLongField(this, 24, text_cursor);
		return this;
	}
	/// C type : Cursor
	@CLong 
	@Field(25) 
	public long nontext_cursor() {
		return this.io.getCLongField(this, 25);
	}
	/// C type : Cursor
	@CLong 
	@Field(25) 
	public x_output nontext_cursor(long nontext_cursor) {
		this.io.setCLongField(this, 25, nontext_cursor);
		return this;
	}
	/// C type : Cursor
	@CLong 
	@Field(26) 
	public long modeline_cursor() {
		return this.io.getCLongField(this, 26);
	}
	/// C type : Cursor
	@CLong 
	@Field(26) 
	public x_output modeline_cursor(long modeline_cursor) {
		this.io.setCLongField(this, 26, modeline_cursor);
		return this;
	}
	/// C type : Cursor
	@CLong 
	@Field(27) 
	public long hand_cursor() {
		return this.io.getCLongField(this, 27);
	}
	/// C type : Cursor
	@CLong 
	@Field(27) 
	public x_output hand_cursor(long hand_cursor) {
		this.io.setCLongField(this, 27, hand_cursor);
		return this;
	}
	/// C type : Cursor
	@CLong 
	@Field(28) 
	public long hourglass_cursor() {
		return this.io.getCLongField(this, 28);
	}
	/// C type : Cursor
	@CLong 
	@Field(28) 
	public x_output hourglass_cursor(long hourglass_cursor) {
		this.io.setCLongField(this, 28, hourglass_cursor);
		return this;
	}
	/// C type : Cursor
	@CLong 
	@Field(29) 
	public long horizontal_drag_cursor() {
		return this.io.getCLongField(this, 29);
	}
	/// C type : Cursor
	@CLong 
	@Field(29) 
	public x_output horizontal_drag_cursor(long horizontal_drag_cursor) {
		this.io.setCLongField(this, 29, horizontal_drag_cursor);
		return this;
	}
	/// C type : Cursor
	@CLong 
	@Field(30) 
	public long current_cursor() {
		return this.io.getCLongField(this, 30);
	}
	/// C type : Cursor
	@CLong 
	@Field(30) 
	public x_output current_cursor(long current_cursor) {
		this.io.setCLongField(this, 30, current_cursor);
		return this;
	}
	/**
	 * Window whose cursor is hourglass_cursor.  This window is temporarily<br>
	 * mapped to display an hourglass cursor.<br>
	 * C type : Window
	 */
	@CLong 
	@Field(31) 
	public long hourglass_window() {
		return this.io.getCLongField(this, 31);
	}
	/**
	 * Window whose cursor is hourglass_cursor.  This window is temporarily<br>
	 * mapped to display an hourglass cursor.<br>
	 * C type : Window
	 */
	@CLong 
	@Field(31) 
	public x_output hourglass_window(long hourglass_window) {
		this.io.setCLongField(this, 31, hourglass_window);
		return this;
	}
	/// Non-zero means hourglass cursor is currently displayed.
	@Field(32) 
	@Bits(1) 
	public int hourglass_p() {
		return this.io.getIntField(this, 32);
	}
	/// Non-zero means hourglass cursor is currently displayed.
	@Field(32) 
	@Bits(1) 
	public x_output hourglass_p(int hourglass_p) {
		this.io.setIntField(this, 32, hourglass_p);
		return this;
	}
	/// Flag to set when the X window needs to be completely repainted.
	@Field(33) 
	public int needs_exposure() {
		return this.io.getIntField(this, 33);
	}
	/// Flag to set when the X window needs to be completely repainted.
	@Field(33) 
	public x_output needs_exposure(int needs_exposure) {
		this.io.setIntField(this, 33, needs_exposure);
		return this;
	}
	/// Conversion Error : XWMHints (Unsupported type)
	/**
	 * This is the Emacs structure for the X display this frame is on.<br>
	 * C type : x_display_info*
	 */
	@Field(34) 
	public Pointer<x_display_info > display_info() {
		return this.io.getPointerField(this, 34);
	}
	/**
	 * This is the Emacs structure for the X display this frame is on.<br>
	 * C type : x_display_info*
	 */
	@Field(34) 
	public x_output display_info(Pointer<x_display_info > display_info) {
		this.io.setPointerField(this, 34, display_info);
		return this;
	}
	/**
	 * This is a button event that wants to activate the menubar.<br>
	 * We save it here until the command loop gets to think about it.<br>
	 * C type : XEvent*
	 */
	@Field(35) 
	public Pointer<XEvent > saved_menu_event() {
		return this.io.getPointerField(this, 35);
	}
	/**
	 * This is a button event that wants to activate the menubar.<br>
	 * We save it here until the command loop gets to think about it.<br>
	 * C type : XEvent*
	 */
	@Field(35) 
	public x_output saved_menu_event(Pointer<XEvent > saved_menu_event) {
		this.io.setPointerField(this, 35, saved_menu_event);
		return this;
	}
	/**
	 * Nonzero means our parent is another application's window<br>
	 * and was explicitly specified.
	 */
	@Field(36) 
	public byte explicit_parent() {
		return this.io.getByteField(this, 36);
	}
	/**
	 * Nonzero means our parent is another application's window<br>
	 * and was explicitly specified.
	 */
	@Field(36) 
	public x_output explicit_parent(byte explicit_parent) {
		this.io.setByteField(this, 36, explicit_parent);
		return this;
	}
	/// Nonzero means tried already to make this frame visible.
	@Field(37) 
	public byte asked_for_visible() {
		return this.io.getByteField(this, 37);
	}
	/// Nonzero means tried already to make this frame visible.
	@Field(37) 
	public x_output asked_for_visible(byte asked_for_visible) {
		this.io.setByteField(this, 37, asked_for_visible);
		return this;
	}
	/// Nonzero if this frame was ever previously visible.
	@Field(38) 
	public byte has_been_visible() {
		return this.io.getByteField(this, 38);
	}
	/// Nonzero if this frame was ever previously visible.
	@Field(38) 
	public x_output has_been_visible(byte has_been_visible) {
		this.io.setByteField(this, 38, has_been_visible);
		return this;
	}
	/**
	 * Relief GCs, colors etc.<br>
	 * C type : relief
	 */
	@Field(39) 
	public x_output.relief black_relief() {
		return this.io.getNativeObjectField(this, 39);
	}
	/**
	 * Relief GCs, colors etc.<br>
	 * C type : relief
	 */
	@Field(39) 
	public x_output black_relief(x_output.relief black_relief) {
		this.io.setNativeObjectField(this, 39, black_relief);
		return this;
	}
	/**
	 * Relief GCs, colors etc.<br>
	 * C type : relief
	 */
	@Field(40) 
	public x_output.relief white_relief() {
		return this.io.getNativeObjectField(this, 40);
	}
	/**
	 * Relief GCs, colors etc.<br>
	 * C type : relief
	 */
	@Field(40) 
	public x_output white_relief(x_output.relief white_relief) {
		this.io.setNativeObjectField(this, 40, white_relief);
		return this;
	}
	/**
	 * The background for which the above relief GCs were set up.<br>
	 * They are changed only when a different background is involved.
	 */
	@CLong 
	@Field(41) 
	public long relief_background() {
		return this.io.getCLongField(this, 41);
	}
	/**
	 * The background for which the above relief GCs were set up.<br>
	 * They are changed only when a different background is involved.
	 */
	@CLong 
	@Field(41) 
	public x_output relief_background(long relief_background) {
		this.io.setCLongField(this, 41, relief_background);
		return this;
	}
	/**
	 * Xt waits for a ConfigureNotify event from the window manager in<br>
	 * EmacsFrameSetCharSize when the shell widget is resized.  For some<br>
	 * window managers like fvwm2 2.2.5 and KDE 2.1 this event doesn't<br>
	 * arrive for an unknown reason and Emacs hangs in Xt.  If this is<br>
	 * zero, tell Xt not to wait.
	 */
	@Field(42) 
	public int wait_for_wm() {
		return this.io.getIntField(this, 42);
	}
	/**
	 * Xt waits for a ConfigureNotify event from the window manager in<br>
	 * EmacsFrameSetCharSize when the shell widget is resized.  For some<br>
	 * window managers like fvwm2 2.2.5 and KDE 2.1 this event doesn't<br>
	 * arrive for an unknown reason and Emacs hangs in Xt.  If this is<br>
	 * zero, tell Xt not to wait.
	 */
	@Field(42) 
	public x_output wait_for_wm(int wait_for_wm) {
		this.io.setIntField(this, 42, wait_for_wm);
		return this;
	}
	/**
	 * As x_pixels_diff, but to FRAME_OUTER_WINDOW.  For some reason the<br>
	 * two might differ by a pixel, depending on WM
	 */
	@Field(43) 
	public int x_pixels_outer_diff() {
		return this.io.getIntField(this, 43);
	}
	/**
	 * As x_pixels_diff, but to FRAME_OUTER_WINDOW.  For some reason the<br>
	 * two might differ by a pixel, depending on WM
	 */
	@Field(43) 
	public x_output x_pixels_outer_diff(int x_pixels_outer_diff) {
		this.io.setIntField(this, 43, x_pixels_outer_diff);
		return this;
	}
	/**
	 * As y_pixels_diff, but to FRAME_OUTER_WINDOW.  In the toolkit version,<br>
	 * these may differ because this does not take into account possible<br>
	 * menubar.  y_pixels_diff is with menubar height included
	 */
	@Field(44) 
	public int y_pixels_outer_diff() {
		return this.io.getIntField(this, 44);
	}
	/**
	 * As y_pixels_diff, but to FRAME_OUTER_WINDOW.  In the toolkit version,<br>
	 * these may differ because this does not take into account possible<br>
	 * menubar.  y_pixels_diff is with menubar height included
	 */
	@Field(44) 
	public x_output y_pixels_outer_diff(int y_pixels_outer_diff) {
		this.io.setIntField(this, 44, y_pixels_outer_diff);
		return this;
	}
	/**
	 * Keep track of focus.  May be EXPLICIT if we received a FocusIn for this<br>
	 * frame, or IMPLICIT if we received an EnterNotify.<br>
	 * FocusOut and LeaveNotify clears EXPLICIT/IMPLICIT.
	 */
	@Field(45) 
	public int focus_state() {
		return this.io.getIntField(this, 45);
	}
	/**
	 * Keep track of focus.  May be EXPLICIT if we received a FocusIn for this<br>
	 * frame, or IMPLICIT if we received an EnterNotify.<br>
	 * FocusOut and LeaveNotify clears EXPLICIT/IMPLICIT.
	 */
	@Field(45) 
	public x_output focus_state(int focus_state) {
		this.io.setIntField(this, 45, focus_state);
		return this;
	}
	/// The offset we need to add to compensate for type A WMs.
	@Field(46) 
	public int move_offset_top() {
		return this.io.getIntField(this, 46);
	}
	/// The offset we need to add to compensate for type A WMs.
	@Field(46) 
	public x_output move_offset_top(int move_offset_top) {
		this.io.setIntField(this, 46, move_offset_top);
		return this;
	}
	@Field(47) 
	public int move_offset_left() {
		return this.io.getIntField(this, 47);
	}
	@Field(47) 
	public x_output move_offset_left(int move_offset_left) {
		this.io.setIntField(this, 47, move_offset_left);
		return this;
	}
	/**
	 * The frame's left/top offsets before we call XMoveWindow.  See<br>
	 * x_check_expected_move.
	 */
	@Field(48) 
	public int left_before_move() {
		return this.io.getIntField(this, 48);
	}
	/**
	 * The frame's left/top offsets before we call XMoveWindow.  See<br>
	 * x_check_expected_move.
	 */
	@Field(48) 
	public x_output left_before_move(int left_before_move) {
		this.io.setIntField(this, 48, left_before_move);
		return this;
	}
	@Field(49) 
	public int top_before_move() {
		return this.io.getIntField(this, 49);
	}
	@Field(49) 
	public x_output top_before_move(int top_before_move) {
		this.io.setIntField(this, 49, top_before_move);
		return this;
	}
	/// Non-zero if _NET_WM_STATE_HIDDEN is set for this frame.
	@Field(50) 
	public int net_wm_state_hidden_seen() {
		return this.io.getIntField(this, 50);
	}
	/// Non-zero if _NET_WM_STATE_HIDDEN is set for this frame.
	@Field(50) 
	public x_output net_wm_state_hidden_seen(int net_wm_state_hidden_seen) {
		this.io.setIntField(this, 50, net_wm_state_hidden_seen);
		return this;
	}
	/// <i>native declaration : xterm.h:2930</i>
	/// <i>native declaration : xterm.h:2930</i>
	public static class relief extends StructObject {
		public relief() {
			super();
		}
		/// C type : GC
		@Field(0) 
		public GC gc() {
			return this.io.getTypedPointerField(this, 0);
		}
		/// C type : GC
		@Field(0) 
		public relief gc(GC gc) {
			this.io.setPointerField(this, 0, gc);
			return this;
		}
		@CLong 
		@Field(1) 
		public long pixel() {
			return this.io.getCLongField(this, 1);
		}
		@CLong 
		@Field(1) 
		public relief pixel(long pixel) {
			this.io.setCLongField(this, 1, pixel);
			return this;
		}
		@Field(2) 
		public int allocated_p() {
			return this.io.getIntField(this, 2);
		}
		@Field(2) 
		public relief allocated_p(int allocated_p) {
			this.io.setIntField(this, 2, allocated_p);
			return this;
		}
	};
}
