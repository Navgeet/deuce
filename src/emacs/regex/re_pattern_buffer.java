package emacs.regex;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Bits;
import org.bridj.ann.CLong;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
import org.bridj.ann.Ptr;
/**
 * <i>native declaration : regex.h:104</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("regex") 
public class re_pattern_buffer extends StructObject {
	public re_pattern_buffer() {
		super();
	}
	/**
	 * Space that holds the compiled pattern.  It is declared as<br>
	 * `unsigned char *' because its elements are<br>
	 * sometimes used as array indexes.<br>
	 * C type : unsigned char*
	 */
	@Field(0) 
	public Pointer<Byte > buffer() {
		return this.io.getPointerField(this, 0);
	}
	/**
	 * Space that holds the compiled pattern.  It is declared as<br>
	 * `unsigned char *' because its elements are<br>
	 * sometimes used as array indexes.<br>
	 * C type : unsigned char*
	 */
	@Field(0) 
	public re_pattern_buffer buffer(Pointer<Byte > buffer) {
		this.io.setPointerField(this, 0, buffer);
		return this;
	}
	/// Number of bytes to which `buffer' points.
	@Ptr 
	@Field(1) 
	public long allocated() {
		return this.io.getSizeTField(this, 1);
	}
	/// Number of bytes to which `buffer' points.
	@Ptr 
	@Field(1) 
	public re_pattern_buffer allocated(long allocated) {
		this.io.setSizeTField(this, 1, allocated);
		return this;
	}
	/// Number of bytes actually used in `buffer'.
	@Ptr 
	@Field(2) 
	public long used() {
		return this.io.getSizeTField(this, 2);
	}
	/// Number of bytes actually used in `buffer'.
	@Ptr 
	@Field(2) 
	public re_pattern_buffer used(long used) {
		this.io.setSizeTField(this, 2, used);
		return this;
	}
	/**
	 * Syntax setting with which the pattern was compiled.<br>
	 * C type : reg_syntax_t
	 */
	@CLong 
	@Field(3) 
	public long syntax() {
		return this.io.getCLongField(this, 3);
	}
	/**
	 * Syntax setting with which the pattern was compiled.<br>
	 * C type : reg_syntax_t
	 */
	@CLong 
	@Field(3) 
	public re_pattern_buffer syntax(long syntax) {
		this.io.setCLongField(this, 3, syntax);
		return this;
	}
	/**
	 * Pointer to a fastmap, if any, otherwise zero.  re_search uses<br>
	 * the fastmap, if there is one, to skip over impossible<br>
	 * starting points for matches.<br>
	 * C type : char*
	 */
	@Field(4) 
	public Pointer<Byte > fastmap() {
		return this.io.getPointerField(this, 4);
	}
	/**
	 * Pointer to a fastmap, if any, otherwise zero.  re_search uses<br>
	 * the fastmap, if there is one, to skip over impossible<br>
	 * starting points for matches.<br>
	 * C type : char*
	 */
	@Field(4) 
	public re_pattern_buffer fastmap(Pointer<Byte > fastmap) {
		this.io.setPointerField(this, 4, fastmap);
		return this;
	}
	/**
	 * Either a translate table to apply to all characters before<br>
	 * comparing them, or zero for no translation.  The translation<br>
	 * is applied to a pattern when it is compiled and to a string<br>
	 * when it is matched.<br>
	 * C type : char*
	 */
	@Field(5) 
	public Pointer<Byte > translate() {
		return this.io.getPointerField(this, 5);
	}
	/**
	 * Either a translate table to apply to all characters before<br>
	 * comparing them, or zero for no translation.  The translation<br>
	 * is applied to a pattern when it is compiled and to a string<br>
	 * when it is matched.<br>
	 * C type : char*
	 */
	@Field(5) 
	public re_pattern_buffer translate(Pointer<Byte > translate) {
		this.io.setPointerField(this, 5, translate);
		return this;
	}
	/// Number of subexpressions found by the compiler.
	@Ptr 
	@Field(6) 
	public long re_nsub() {
		return this.io.getSizeTField(this, 6);
	}
	/// Number of subexpressions found by the compiler.
	@Ptr 
	@Field(6) 
	public re_pattern_buffer re_nsub(long re_nsub) {
		this.io.setSizeTField(this, 6, re_nsub);
		return this;
	}
	/**
	 * Zero if this pattern cannot match the empty string, one else.<br>
	 * Well, in truth it's used only in `re_search_2', to see<br>
	 * whether or not we should use the fastmap, so we don't set<br>
	 * this absolutely perfectly; see `re_compile_fastmap'.
	 */
	@Field(7) 
	@Bits(1) 
	public int can_be_null() {
		return this.io.getIntField(this, 7);
	}
	/**
	 * Zero if this pattern cannot match the empty string, one else.<br>
	 * Well, in truth it's used only in `re_search_2', to see<br>
	 * whether or not we should use the fastmap, so we don't set<br>
	 * this absolutely perfectly; see `re_compile_fastmap'.
	 */
	@Field(7) 
	@Bits(1) 
	public re_pattern_buffer can_be_null(int can_be_null) {
		this.io.setIntField(this, 7, can_be_null);
		return this;
	}
	@Field(8) 
	@Bits(2) 
	public int regs_allocated() {
		return this.io.getIntField(this, 8);
	}
	@Field(8) 
	@Bits(2) 
	public re_pattern_buffer regs_allocated(int regs_allocated) {
		this.io.setIntField(this, 8, regs_allocated);
		return this;
	}
	/**
	 * Set to zero when `regex_compile' compiles a pattern; set to one<br>
	 * by `re_compile_fastmap' if it updates the fastmap.
	 */
	@Field(9) 
	@Bits(1) 
	public int fastmap_accurate() {
		return this.io.getIntField(this, 9);
	}
	/**
	 * Set to zero when `regex_compile' compiles a pattern; set to one<br>
	 * by `re_compile_fastmap' if it updates the fastmap.
	 */
	@Field(9) 
	@Bits(1) 
	public re_pattern_buffer fastmap_accurate(int fastmap_accurate) {
		this.io.setIntField(this, 9, fastmap_accurate);
		return this;
	}
	/**
	 * If set, `re_match_2' does not return information about<br>
	 * subexpressions.
	 */
	@Field(10) 
	@Bits(1) 
	public int no_sub() {
		return this.io.getIntField(this, 10);
	}
	/**
	 * If set, `re_match_2' does not return information about<br>
	 * subexpressions.
	 */
	@Field(10) 
	@Bits(1) 
	public re_pattern_buffer no_sub(int no_sub) {
		this.io.setIntField(this, 10, no_sub);
		return this;
	}
	/**
	 * If set, a beginning-of-line anchor doesn't match at the<br>
	 * beginning of the string.
	 */
	@Field(11) 
	@Bits(1) 
	public int not_bol() {
		return this.io.getIntField(this, 11);
	}
	/**
	 * If set, a beginning-of-line anchor doesn't match at the<br>
	 * beginning of the string.
	 */
	@Field(11) 
	@Bits(1) 
	public re_pattern_buffer not_bol(int not_bol) {
		this.io.setIntField(this, 11, not_bol);
		return this;
	}
	/// Similarly for an end-of-line anchor.
	@Field(12) 
	@Bits(1) 
	public int not_eol() {
		return this.io.getIntField(this, 12);
	}
	/// Similarly for an end-of-line anchor.
	@Field(12) 
	@Bits(1) 
	public re_pattern_buffer not_eol(int not_eol) {
		this.io.setIntField(this, 12, not_eol);
		return this;
	}
	/**
	 * If true, the compilation of the pattern had to look up the syntax table,<br>
	 * so the compiled pattern is only valid for the current syntax table.
	 */
	@Field(13) 
	@Bits(1) 
	public int used_syntax() {
		return this.io.getIntField(this, 13);
	}
	/**
	 * If true, the compilation of the pattern had to look up the syntax table,<br>
	 * so the compiled pattern is only valid for the current syntax table.
	 */
	@Field(13) 
	@Bits(1) 
	public re_pattern_buffer used_syntax(int used_syntax) {
		this.io.setIntField(this, 13, used_syntax);
		return this;
	}
}
